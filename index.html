<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Arena - Void Singularity Update</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff00ff;
            --neon-yellow: #f0ff00;
            --neon-purple: #bc13fe;
            --neon-orange: #ff8c00;
            --neon-green: #39ff14;
            --neon-red: #ff3131;
            --neon-white: #ffffff;
            --neon-phoenix: #ff4d00;
            --neon-hong: #8b4513;
            --neon-tamin: #2ecc71;
            --neon-jingle: #ff2e2e;
            --neon-gangbuk: #ffcc00;
            --neon-hanzo: #00ffcc;
            --neon-dragon: #ff0055;
            --neon-void: #4a00e0;
            --dark-bg: #050505;
        }
        body {
            font-family: 'Noto Sans KR', 'Montserrat', sans-serif;
            background-color: var(--dark-bg);
            color: white;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }
        canvas { display: block; background: #080808; }
        .glass {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.8);
        }
        .bg-grid {
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
            background-size: 60px 60px;
        }
        .stat-bar-bg { width: 100%; height: 8px; background: rgba(255,255,255,0.05); border-radius: 10px; overflow: hidden; }
        .stat-bar-fill { height: 100%; border-radius: 10px; transition: width 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        
        .mode-btn { cursor: pointer; transition: all 0.3s; opacity: 0.3; }
        .mode-btn.active { opacity: 1; transform: scale(1.1); text-shadow: 0 0 15px white; }
        
        .arrow-btn {
            background: rgba(255,255,255,0.05);
            transition: all 0.2s;
            cursor: pointer;
            width: 50px; height: 50px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 50%;
            font-size: 1.2rem;
        }
        .arrow-btn:hover { background: rgba(255,255,255,0.15); transform: scale(1.1); box-shadow: 0 0 15px rgba(255,255,255,0.2); }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 40px; z-index: 10;
        }
        .hp-bar-outer { 
            width: 350px; height: 16px; background: rgba(255, 255, 255, 0.05); 
            border-radius: 20px; overflow: hidden; border: 1px solid rgba(255,255,255,0.1);
        }
        .hp-bar-inner { height: 100%; transition: width 0.2s ease-out; box-shadow: 0 0 20px currentColor; }

        .cd-slot {
            width: 60px; height: 60px; border-radius: 15px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.7); border: 2px solid rgba(255,255,255,0.1);
            position: relative; overflow: hidden; transition: all 0.3s;
        }
        .cd-fill {
            position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(255,255,255,0.2);
            transition: height 0.1s linear;
        }
        .cd-ready { border-color: white; transform: translateY(-3px); box-shadow: 0 5px 15px rgba(255,255,255,0.15); }

        #game-over {
            position: fixed; inset: 0; background: rgba(0,0,0,0.96);
            display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
        }
        .btn-round {
            padding: 1.2rem 3rem; border-radius: 100px; font-weight: 900; text-transform: uppercase;
            letter-spacing: 0.1em; transition: all 0.3s; cursor: pointer;
        }
    </style>
</head>
<body class="bg-grid">

    <!-- Lobby Menu -->
    <div id="lobby" class="fixed inset-0 z-[100] flex flex-col items-center justify-between py-16 px-8 bg-black/95">
        <div class="text-center">
            <h1 class="text-6xl font-black italic tracking-tighter mb-4">NEON <span class="text-white/30">ARENA</span></h1>
            <div class="flex gap-10 justify-center mt-6">
                <div onclick="setGameMode('pvp')" id="mode-pvp" class="mode-btn active text-sm font-black tracking-[0.3em] uppercase">PVP DUEL</div>
                <div onclick="setGameMode('pve')" id="mode-pve" class="mode-btn text-sm font-black tracking-[0.3em] uppercase">AI PRACTICE</div>
            </div>
        </div>

        <div class="flex items-center gap-16">
            <!-- P1 Selection -->
            <div class="flex flex-col items-center">
                <div class="text-[10px] font-black tracking-[0.4em] mb-6 opacity-40 uppercase">Vanguard 01</div>
                <div class="flex items-center gap-6">
                    <div onclick="prevChar(1)" class="arrow-btn">◀</div>
                    <div id="p1-card" class="glass rounded-[40px] p-8 flex flex-col items-center justify-between w-[320px] h-[420px] border-b-[6px]">
                        <div id="p1-char-code" class="text-7xl font-black italic opacity-10">NB</div>
                        <div class="w-full">
                            <h2 id="p1-char-name" class="text-2xl font-black italic mb-6 text-center tracking-tight">NEON BLADE</h2>
                            <div class="space-y-4" id="p1-stats-container"></div>
                        </div>
                    </div>
                    <div onclick="nextChar(1)" class="arrow-btn">▶</div>
                </div>
            </div>

            <div class="flex flex-col items-center gap-6">
                <div class="text-5xl font-black italic opacity-5 tracking-tighter">VS</div>
                <button onclick="randomizeBoth()" class="glass px-8 py-3 rounded-full text-[11px] font-black hover:bg-white/10 transition tracking-widest uppercase border border-white/10">Randomize</button>
            </div>

            <!-- P2 Selection -->
            <div class="flex flex-col items-center">
                <div class="text-[10px] font-black tracking-[0.4em] mb-6 opacity-40 uppercase text-pink-500">Vanguard 02</div>
                <div class="flex items-center gap-6">
                    <div onclick="prevChar(2)" class="arrow-btn">◀</div>
                    <div id="p2-card" class="glass rounded-[40px] p-8 flex flex-col items-center justify-between w-[320px] h-[420px] border-b-[6px]">
                        <div id="p2-char-code" class="text-7xl font-black italic opacity-10">CS</div>
                        <div class="w-full">
                            <h2 id="p2-char-name" class="text-2xl font-black italic mb-6 text-center tracking-tight">CYBER STING</h2>
                            <div class="space-y-4" id="p2-stats-container"></div>
                        </div>
                    </div>
                    <div onclick="nextChar(2)" class="arrow-btn">▶</div>
                </div>
            </div>
        </div>

        <button onclick="startGame()" class="btn-round bg-white text-black hover:scale-110 active:scale-95 shadow-[0_0_30px_rgba(255,255,255,0.3)]">Engage Protocol</button>
    </div>

    <!-- In-Game UI -->
    <div id="ingame-ui" class="ui-layer hidden">
        <div class="flex justify-between items-start">
            <div class="flex flex-col gap-2">
                <div id="p1-name-ui" class="text-xl font-black italic tracking-tighter uppercase">P1</div>
                <div class="hp-bar-outer"><div id="p1-hp" class="hp-bar-inner"></div></div>
                <div id="p1-passive-ui" class="text-[10px] font-black opacity-60"></div>
            </div>
            <div class="text-center">
                <div id="timer" class="text-5xl font-black italic opacity-20 tracking-tighter">99</div>
            </div>
            <div class="flex flex-col items-end gap-2">
                <div id="p2-name-ui" class="text-xl font-black italic tracking-tighter text-right uppercase">P2</div>
                <div class="hp-bar-outer"><div id="p2-hp" class="hp-bar-inner"></div></div>
                <div id="p2-passive-ui" class="text-[10px] font-black opacity-60"></div>
            </div>
        </div>

        <!-- Cooldowns HUD -->
        <div class="fixed bottom-10 left-0 right-0 flex justify-between px-20 pointer-events-none">
            <!-- P1 HUD -->
            <div class="flex gap-4 items-center">
                <div id="p1-dash-slot" class="cd-slot">
                    <div id="p1-dash-fill" class="cd-fill"></div>
                    <span class="text-[10px] font-black z-10">DASH</span>
                    <span class="text-[8px] opacity-40 z-10 font-bold">Q</span>
                </div>
                <div id="p1-skill-slot" class="cd-slot">
                    <div id="p1-skill-fill" class="cd-fill"></div>
                    <span class="text-[10px] font-black z-10">SKILL</span>
                    <span class="text-[8px] opacity-40 z-10 font-bold">E</span>
                </div>
                <div class="ml-2 text-left">
                    <div class="text-[10px] font-black opacity-30 uppercase">Player 1 Status</div>
                    <div id="p1-char-label" class="text-xs font-black italic tracking-tighter">READY</div>
                </div>
            </div>

            <!-- P2 HUD -->
            <div class="flex gap-4 items-center flex-row-reverse">
                <div id="p2-dash-slot" class="cd-slot">
                    <div id="p2-dash-fill" class="cd-fill"></div>
                    <span class="text-[10px] font-black z-10">DASH</span>
                    <span class="text-[8px] opacity-40 z-10 font-bold">K</span>
                </div>
                <div id="p2-skill-slot" class="cd-slot">
                    <div id="p2-skill-fill" class="cd-fill"></div>
                    <span class="text-[10px] font-black z-10">SKILL</span>
                    <span class="text-[8px] opacity-40 z-10 font-bold">L</span>
                </div>
                <div class="mr-2 text-right">
                    <div class="text-[10px] font-black opacity-30 uppercase">Player 2 Status</div>
                    <div id="p2-char-label" class="text-xs font-black italic tracking-tighter">READY</div>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over">
        <h2 id="winner-text" class="text-8xl font-black italic mb-10 tracking-tighter uppercase">TERMINATED</h2>
        <button onclick="goToMenu()" class="btn-round border-2 border-white/20 hover:border-white text-white">Return to Base</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // Assets Loading
        const dragonImg = new Image();
        dragonImg.src = 'https://i.ifh.cc/pPrAjV.png';

        const blackHoleImg = new Image();
        blackHoleImg.src = 'https://i.ifh.cc/NWTLPJ.png';

        // Sound System Implementation
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        const sounds = {
            attack: (freq = 150) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            },
            hit: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.15);
            },
            dash: () => {
                const noise = audioCtx.createBufferSource();
                const bufferSize = audioCtx.sampleRate * 0.1;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
                noise.start();
            },
            skill: (f = 440) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(f, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(f * 2, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            },
            bell: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(987.77, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.5);
                const osc2 = audioCtx.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(1318.51, audioCtx.currentTime);
                const gain2 = audioCtx.createGain();
                gain2.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain2.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                osc2.connect(gain2); gain2.connect(audioCtx.destination);
                osc2.start(); osc2.stop(audioCtx.currentTime + 0.4);
            },
            explosion: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 1.5);
                gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.5);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 1.5);
            },
            dragonRoar: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(40, audioCtx.currentTime);
                osc.frequency.linearRampToValueAtTime(150, audioCtx.currentTime + 0.2);
                osc.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 1.5);
                gain.gain.setValueAtTime(0.7, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.5);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 1.5);
            },
            voidHum: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.8);
                gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.8);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.8);
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameActive = false;
        let gameMode = 'pvp';
        let timeLeft = 99;
        let screenShake = 0;
        let mouseX = 0, mouseY = 0;
        const keys = {};

        const CHARS = [
            { id: 'void', name: 'VOID REAPER', code: 'VR', color: '#4a00e0', speed: 6.5, damage: 14, range: 220, stats: { spd: 70, dmg: 85, rng: 80 } },
            { id: 'shinryu', name: 'SHINRYU', code: 'SR', color: '#ff0055', speed: 7.2, damage: 16, range: 180, stats: { spd: 75, dmg: 95, rng: 85 } },
            { id: 'hanzo', name: 'HANZO', code: 'HZ', color: '#00ffcc', speed: 8.5, damage: 10, range: 350, stats: { spd: 95, dmg: 55, rng: 90 } },
            { id: 'gangbuk', name: 'GANGBUK', code: 'GB', color: '#ffcc00', speed: 6.8, damage: 15, range: 160, stats: { spd: 70, dmg: 85, rng: 65 } },
            { id: 'blade', name: 'NEON BLADE', code: 'NB', color: '#00f2ff', speed: 7.0, damage: 12, range: 140, stats: { spd: 80, dmg: 60, rng: 60 } },
            { id: 'sting', name: 'CYBER STING', code: 'CS', color: '#ff00ff', speed: 7.8, damage: 7, range: 280, stats: { spd: 90, dmg: 40, rng: 100 } },
            { id: 'volt', name: 'VOLT STRIKER', code: 'VS', color: '#f0ff00', speed: 6.5, damage: 13, range: 180, stats: { spd: 75, dmg: 65, rng: 80 } },
            { id: 'shadow', name: 'SHADOW PHANTOM', code: 'SP', color: '#bc13fe', speed: 8.2, damage: 15, range: 120, stats: { spd: 100, dmg: 75, rng: 45 } },
            { id: 'phoenix', name: 'PHOENIX WING', code: 'PW', color: '#ff4d00', speed: 7.5, damage: 8, range: 220, stats: { spd: 85, dmg: 40, rng: 85 } },
            { id: 'hong', name: 'HONG AJEO-SSI', code: 'HG', color: '#8b4513', speed: 6.0, damage: 11, range: 130, stats: { spd: 55, dmg: 55, rng: 50 } },
            { id: 'tamin', name: 'TTATTARATTA-TAMIN', code: 'TM', color: '#2ecc71', speed: 6.8, damage: 10, range: 400, stats: { spd: 70, dmg: 90, rng: 95 } },
            { id: 'jingle', name: 'JINGLE-BELL ROCK', code: 'JR', color: '#ff2e2e', speed: 7.1, damage: 11, range: 300, stats: { spd: 75, dmg: 60, rng: 85 } },
            { id: 'titan', name: 'GRAVITY TITAN', code: 'GT', color: '#ff8c00', speed: 5.5, damage: 18, range: 170, stats: { spd: 40, dmg: 85, rng: 75 } },
            { id: 'bulwark', name: 'IRON BULWARK', code: 'IB', color: '#94a3b8', speed: 4.8, damage: 20, range: 150, stats: { spd: 30, dmg: 95, rng: 55 } },
            { id: 'hacker', name: 'GLITCH HACKER', code: 'GH', color: '#39ff14', speed: 7.4, damage: 14, range: 220, stats: { spd: 85, dmg: 70, rng: 90 } },
            { id: 'reaper', name: 'PLASMA REAPER', code: 'PR', color: '#ff3131', speed: 6.2, damage: 14, range: 200, stats: { spd: 65, dmg: 70, rng: 85 } },
            { id: 'ez', name: 'ALPANOZIAN', code: 'EZ', color: '#ffffff', speed: 7.2, damage: 13, range: 110, stats: { spd: 80, dmg: 65, rng: 50 } },
            { id: 'bb', name: 'BEAT BREAKER', code: 'BB', color: '#00ffaa', speed: 7.0, damage: 12, range: 240, stats: { spd: 75, dmg: 60, rng: 85 } }
        ];

        let p1Idx = 0, p2Idx = 1;

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
        window.addEventListener('mousedown', e => { 
            initAudio();
            if(!gameActive || gameMode !== 'pve') return;
            if(e.button === 0) p1.attack();
            if(e.button === 2) p1.useSkill();
        });
        window.addEventListener('contextmenu', e => e.preventDefault());

        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize); resize();

        function setGameMode(mode) {
            gameMode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('mode-' + mode).classList.add('active');
        }

        function updateCharUI(pNum) {
            const idx = pNum === 1 ? p1Idx : p2Idx;
            const data = CHARS[idx];
            const prefix = pNum === 1 ? 'p1' : 'p2';
            const card = document.getElementById(`${prefix}-card`);
            card.style.borderBottomColor = data.color;
            document.getElementById(`${prefix}-char-code`).innerText = data.code;
            document.getElementById(`${prefix}-char-code`).style.color = data.color;
            document.getElementById(`${prefix}-char-name`).innerText = data.name;
            document.getElementById(`${prefix}-char-name`).style.color = data.color;
            
            const container = document.getElementById(`${prefix}-stats-container`);
            container.innerHTML = '';
            ['spd', 'dmg', 'rng'].forEach(s => {
                container.innerHTML += `
                    <div>
                        <div class="flex justify-between text-[10px] font-black mb-2 opacity-40"><span>${s.toUpperCase()}</span><span>${data.stats[s]}</span></div>
                        <div class="stat-bar-bg"><div class="stat-bar-fill shadow-[0_0_10px_${data.color}]" style="width: ${data.stats[s]}%; background: ${data.color}"></div></div>
                    </div>`;
            });
        }

        function nextChar(pNum) { if(pNum === 1) p1Idx = (p1Idx+1)%CHARS.length; else p2Idx = (p2Idx+1)%CHARS.length; updateCharUI(pNum); }
        function prevChar(pNum) { if(pNum === 1) p1Idx = (p1Idx-1+CHARS.length)%CHARS.length; else p2Idx = (p2Idx-1+CHARS.length)%CHARS.length; updateCharUI(pNum); }
        function randomizeBoth() { 
            p1Idx = Math.floor(Math.random()*CHARS.length); 
            p2Idx = Math.floor(Math.random()*CHARS.length); 
            updateCharUI(1); updateCharUI(2); 
        }

        function startGame() {
            initAudio();
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('ingame-ui').classList.remove('hidden');
            p1.init(p1Idx, 400, canvas.height/2);
            p2.init(p2Idx, canvas.width - 400, canvas.height/2);
            document.getElementById('p1-name-ui').innerText = p1.name;
            document.getElementById('p1-name-ui').style.color = p1.color;
            document.getElementById('p2-name-ui').innerText = p2.name;
            document.getElementById('p2-name-ui').style.color = p2.color;
            document.getElementById('p1-char-label').innerText = p1.name;
            document.getElementById('p2-char-label').innerText = p2.name;
            
            document.getElementById('p1-passive-ui').innerText = getPassiveText(p1);
            document.getElementById('p2-passive-ui').innerText = getPassiveText(p2);

            gameActive = true; timeLeft = 99;
            projectiles = [];
        }

        function getPassiveText(p) {
            if(p.type === 'void') return 'PASSIVE: 공포의 심연 (공격 시 이동속도 감소)';
            if(p.type === 'shinryu') return 'PASSIVE: 신룡의 비늘 (상시 데미지 감소)';
            if(p.type === 'hanzo') return 'PASSIVE: 그림자 걸음 (기본 속도 최상)';
            if(p.type === 'gangbuk') return 'PASSIVE: 선글라스의 위엄 (반사 광채)';
            if(p.type === 'phoenix') return 'PASSIVE: REBIRTH [READY]';
            if(p.type === 'hong') return 'PASSIVE: 연륜의 여유 (데미지 경감)';
            if(p.type === 'tamin') return 'PASSIVE: 쮠똬 (회피 확률 0.67%)';
            if(p.type === 'jingle') return 'PASSIVE: 리드미컬 징글';
            return '';
        }

        function goToMenu() {
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('lobby').style.display = 'flex';
            document.getElementById('ingame-ui').classList.add('hidden');
            gameActive = false;
        }

        class Player {
            constructor(id) {
                this.id = id; this.radius = 35; this.hp = 100;
            }
            init(idx, x, y) {
                const d = CHARS[idx];
                this.type = d.id; this.name = d.name; this.color = d.color;
                this.speed = d.speed; this.baseDmg = d.damage; this.range = d.range;
                this.x = x; this.y = y; this.hp = 100; this.angle = this.id === 1 ? 0 : Math.PI;
                this.dashCD = 0; this.skillCD = 0; this.attackCD = 0;
                this.isAttacking = false; this.isSkillActive = false; this.isDashing = false;
                this.invul = 0; this.slowEffect = 0;
                this.lastDamageTaken = 0;
                this.hasRebirth = (this.type === 'phoenix');
                this.isStunned = 0;
                this.nukeState = null;
                this.dragonHeadState = null;
                this.blackHoleState = null;
            }

            update() {
                if(!gameActive) return;
                if(this.dashCD > 0) this.dashCD--;
                if(this.skillCD > 0) this.skillCD--;
                if(this.attackCD > 0) this.attackCD--;
                if(this.invul > 0) this.invul--;
                if(this.slowEffect > 0) this.slowEffect--;
                if(this.isStunned > 0) this.isStunned--;

                // Void Reaper Blackhole Logic
                if(this.blackHoleState) {
                    this.blackHoleState.timer--;
                    const target = this.id === 1 ? p2 : p1;
                    const bh = this.blackHoleState;
                    const d = Math.hypot(target.x - bh.x, target.y - bh.y);
                    if(bh.timer > 0) {
                        if(d < 350) {
                            // Pull target
                            const ang = Math.atan2(bh.y - target.y, bh.x - target.x);
                            target.x += Math.cos(ang) * 6;
                            target.y += Math.sin(ang) * 6;
                            // Continuous damage
                            if(bh.timer % 15 === 0) target.takeDamage(1.5);
                        }
                    } else {
                        this.blackHoleState = null;
                        this.isSkillActive = false;
                    }
                }

                // Shinryu Skill Logic
                if(this.dragonHeadState) {
                    this.dragonHeadState.timer--;
                    if(this.dragonHeadState.timer <= 0) {
                        this.dragonHeadState = null;
                        this.isSkillActive = false;
                    } else if(this.dragonHeadState.timer === 70) {
                        const target = this.id === 1 ? p2 : p1;
                        target.takeDamage(45);
                        target.isStunned = 120;
                        screenShake = 120;
                    }
                }

                // Gangbuk Nuke Logic
                if(this.nukeState) {
                    this.nukeState.timer--;
                    const target = this.id === 1 ? p2 : p1;
                    if(this.nukeState.phase === 'track') {
                        this.nukeState.x = target.x; this.nukeState.y = target.y;
                        if(this.nukeState.timer <= 60) this.nukeState.phase = 'warn'; 
                    } else if(this.nukeState.phase === 'warn') {
                         if(this.nukeState.timer <= 0) {
                             this.nukeState.phase = 'impact'; this.triggerNukeImpact();
                         }
                    }
                }

                if(this.type === 'tamin' && Math.random() < 0.0067) {
                    this.isStunned = 30; this.invul = 30; sounds.skill(100);
                }

                const other = this.id === 1 ? p2 : p1;
                if(gameMode === 'pve' && this.id === 1) this.angle = Math.atan2(mouseY-this.y, mouseX-this.x);
                else this.angle = Math.atan2(other.y-this.y, other.x-this.x);

                if(this.isStunned > 0) return;

                if(this.isDashing) {
                    this.x += Math.cos(this.dashAngle)*32; this.y += Math.sin(this.dashAngle)*32;
                    if(--this.dashTime <= 0) this.isDashing = false;
                } else {
                    this.x += (this.velX || 0) * (this.slowEffect > 0 ? 0.3 : 1); 
                    this.y += (this.velY || 0) * (this.slowEffect > 0 ? 0.3 : 1);
                }

                if(this.isAttacking && (this.atkProg += 0.2) >= 1) this.isAttacking = false;
                if(this.isSkillActive && (this.skillProg += 0.01) >= 1) this.isSkillActive = false;

                if(this.type === 'titan' && this.isSkillActive) {
                    const d = Math.hypot(other.x-this.x, other.y-this.y);
                    if(d < 500) { other.x += (this.x - other.x) * 0.12; other.y += (this.y - other.y) * 0.12; }
                }
                if(this.type === 'bulwark' && this.isSkillActive) {
                    this.invul = 5; 
                    const d = Math.hypot(other.x-this.x, other.y-this.y);
                    if(d < 250 && Math.random() < 0.1) other.takeDamage(1.5);
                }
                if(this.type === 'reaper' && this.isSkillActive) {
                    const d = Math.hypot(other.x-this.x, other.y-this.y);
                    if(d < 350) other.slowEffect = 5;
                }

                this.x = Math.max(this.radius, Math.min(canvas.width-this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(canvas.height-this.radius, this.y));
                if(gameMode === 'pve' && this.id === 2) this.updateAI();
            }

            triggerNukeImpact() {
                const other = this.id === 1 ? p2 : p1;
                sounds.explosion(); screenShake = 60;
                const d = Math.hypot(other.x - this.nukeState.x, other.y - this.nukeState.y);
                if(d < 250) { other.takeDamage(45); other.isStunned = 60; }
                this.nukeState.phase = 'cloud'; this.nukeState.timer = 60; 
                setTimeout(() => { this.nukeState = null; this.isSkillActive = false; }, 1000);
            }

            updateAI() {
                const other = p1;
                const d = Math.hypot(other.x-this.x, other.y-this.y);
                const idealDist = this.range * 0.8;
                if(d > idealDist + 20) { this.velX = Math.cos(this.angle)*this.speed; this.velY = Math.sin(this.angle)*this.speed; }
                else if(d < idealDist - 50) { this.velX = -Math.cos(this.angle)*this.speed; this.velY = -Math.sin(this.angle)*this.speed; }
                else {
                    this.velX = Math.cos(this.angle + Math.PI/2) * (Math.sin(Date.now()/500) * 4);
                    this.velY = Math.sin(this.angle + Math.PI/2) * (Math.sin(Date.now()/500) * 4);
                    this.attack(); 
                }
                if(d < 400 && Math.random() < 0.02) this.useSkill();
                if(d < 150 && Math.random() < 0.05) this.dash();
            }

            attack() {
                if(this.attackCD > 0 || this.isDashing || this.isStunned > 0) return;
                this.isAttacking = true; this.atkProg = 0; this.attackCD = 22;
                if(this.type === 'jingle') sounds.bell();
                else sounds.attack(150 + Math.random()*100);

                const other = this.id === 1 ? p2 : p1;
                if(this.type === 'shinryu') {
                    for(let i=0; i<3; i++) projectiles.push(new Projectile(this.x, this.y, this.angle + (Math.random()-0.5)*0.3, this.color, this, false, 'fire'));
                } else if(this.type === 'hanzo') {
                    projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'shuriken'));
                } else if(this.type === 'gangbuk') {
                    projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'gold'));
                } else if(this.type === 'tamin') {
                    this.attackCD = 100;
                    for(let i=0; i<20; i++) setTimeout(() => { if(!gameActive) return; projectiles.push(new Projectile(this.x, this.y, this.angle + (Math.random()-0.5)*0.1, this.color, this, false, 'paper')); }, i * 30);
                } else if(this.type === 'jingle' || this.type === 'sting' || this.type === 'hacker' || this.type === 'bb' || this.type === 'phoenix') {
                    if(this.type === 'phoenix') { for(let i=-1; i<=1; i++) projectiles.push(new Projectile(this.x, this.y, this.angle + i*0.2, this.color, this, false, 'fire')); } 
                    else { projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, this.type === 'hacker', this.type === 'bb' ? 'wave' : (this.type === 'jingle' ? 'note' : 'orb'))); }
                } else {
                    const d = Math.hypot(other.x-this.x, other.y-this.y);
                    const angTo = Math.atan2(other.y-this.y, other.x-this.x);
                    let diff = Math.abs(this.angle - angTo);
                    if(diff > Math.PI) diff = 2*Math.PI-diff;
                    if(d < this.range && diff < 0.8) {
                        let finalDmg = this.baseDmg;
                        if(this.type === 'ez') {
                            if(this.baseDmg > other.baseDmg) finalDmg *= 1.15; else if(this.baseDmg < other.baseDmg) finalDmg *= 0.9;
                            finalDmg += this.lastDamageTaken * 0.05; this.lastDamageTaken = 0;
                        }
                        if(this.type === 'void') {
                             other.slowEffect = 60; // Slow down on hit
                        }
                        other.takeDamage(finalDmg);
                        screenShake = (this.type === 'titan' || this.type === 'reaper' || this.type === 'bulwark' || this.type === 'hong' || this.type === 'void') ? 15 : 8;
                    }
                }
            }

            useSkill() {
                if(this.skillCD > 0 || this.isStunned > 0) return;
                this.skillCD = 800; this.isSkillActive = true; this.skillProg = 0;
                const other = this.id === 1 ? p2 : p1;

                if(this.type === 'void') {
                    sounds.voidHum(); screenShake = 40;
                    this.blackHoleState = { x: other.x, y: other.y, timer: 180 };
                    return;
                }

                if(this.type === 'shinryu') {
                    sounds.dragonRoar(); screenShake = 80;
                    this.dragonHeadState = { timer: 150 };
                    return;
                }

                if(this.type === 'hanzo') {
                    sounds.skill(600); this.invul = 60;
                    [0, Math.PI/2, Math.PI, Math.PI*1.5].forEach(ang => {
                        const sx = other.x + Math.cos(ang) * 200; const sy = other.y + Math.sin(ang) * 200;
                        projectiles.push(new Projectile(sx, sy, Math.atan2(other.y - sy, other.x - sx), this.color, this, false, 'shuriken'));
                    });
                    return;
                }

                if(this.type === 'gangbuk') {
                    sounds.skill(200); this.nukeState = { phase: 'track', x: other.x, y: other.y, timer: 180 };
                    return;
                }

                if(this.type === 'jingle') {
                    sounds.bell(); setTimeout(() => sounds.bell(), 200);
                    other.isStunned = 180; other.skillCD = 180;
                    const danceTimer = setInterval(() => { if(!gameActive || other.isStunned <= 0) { clearInterval(danceTimer); return; } other.x += (Math.random() - 0.5) * 10; other.y += (Math.random() - 0.5) * 10; }, 50);
                    setTimeout(() => clearInterval(danceTimer), 3000);
                } else { sounds.skill(300 + Math.random()*200); }

                if(this.type === 'tamin') {
                    const targetX = other.x, targetY = other.y; other.isStunned = 120;
                    const bindTimer = setInterval(() => { if(!gameActive || other.isStunned <= 0) { clearInterval(bindTimer); return; } other.takeDamage(1); other.x = targetX; other.y = targetY; }, 50);
                    setTimeout(() => clearInterval(bindTimer), 2000);
                } else if(this.type === 'hong') {
                    screenShake = 35; if(Math.hypot(other.x-this.x, other.y-this.y) < 400) other.slowEffect = 180;
                    for(let i=0; i<8; i++) setTimeout(() => {
                        let sx, sy, side = Math.floor(Math.random() * 4);
                        if(side === 0) { sx = 0; sy = Math.random()*canvas.height; } else if(side === 1) { sx = canvas.width; sy = Math.random()*canvas.height; }
                        else if(side === 2) { sx = Math.random()*canvas.width; sy = 0; } else { sx = Math.random()*canvas.width; sy = canvas.height; }
                        projectiles.push(new Projectile(sx, sy, Math.atan2(other.y - sy, other.x - sx), '#ffcc00', this, false, 'hog'));
                    }, i * 250);
                } else if(this.type === 'phoenix') {
                    screenShake = 30; if(Math.hypot(other.x-this.x, other.y-this.y) < 450) {
                        other.takeDamage(22); const ang = Math.atan2(other.y-this.y, other.x-this.x);
                        other.x += Math.cos(ang) * 150; other.y += Math.sin(ang) * 150; other.slowEffect = 60;
                    }
                } else if(this.type === 'bulwark') {
                    this.invul = 150; const pulse = setInterval(() => { if(this.skillProg >= 1) clearInterval(pulse); if(Math.hypot(other.x-this.x, other.y-this.y) < 300) {
                        const ang = Math.atan2(other.y-this.y, other.x-this.x); other.x += Math.cos(ang) * 5; other.y += Math.sin(ang) * 5;
                    }}, 16);
                } else if(this.type === 'ez') {
                    for(let i=0; i<3; i++) setTimeout(() => {
                        let sx, sy, sa, side = Math.floor(Math.random() * 4);
                        if(side === 0) { sx = -200; sy = other.y; sa = 0; } else if(side === 1) { sx = canvas.width + 200; sy = other.y; sa = Math.PI; }
                        else if(side === 2) { sx = other.x; sy = -200; sa = Math.PI/2; } else { sx = other.x; sy = canvas.height + 200; sa = -Math.PI/2; }
                        projectiles.push(new Projectile(sx, sy, sa, '#ff0000', this, false, 'car'));
                    }, i * 600);
                } else if(this.type === 'bb') {
                    screenShake = 25; if(Math.hypot(other.x-this.x, other.y-this.y) < 380) {
                        other.takeDamage(22); const ang = Math.atan2(other.y-this.y, other.x-this.x); other.x += Math.cos(ang) * 120; other.y += Math.sin(ang) * 120;
                    }
                } else if(this.type === 'blade') {
                    this.isDashing = true; this.dashTime = 14; this.dashAngle = this.angle;
                    setTimeout(() => { if(Math.hypot(this.x-other.x, this.y-other.y) < 180) other.takeDamage(25); }, 150);
                } else if(this.type === 'shadow') {
                    this.invul = 40; setTimeout(() => { this.x = other.x + Math.cos(this.angle+Math.PI)*120; this.y = other.y + Math.sin(this.angle+Math.PI)*120; other.takeDamage(20); }, 200);
                } else if(this.type === 'volt') {
                    this.isDashing = true; this.dashTime = 25; this.dashAngle = this.angle;
                    const checkVolt = setInterval(() => { if(!this.isDashing) clearInterval(checkVolt); if(Math.hypot(this.x-other.x, this.y-other.y) < 80) other.takeDamage(1); }, 50);
                } else if(this.type === 'sting') { for(let i=0; i<12; i++) projectiles.push(new Projectile(this.x, this.y, (Math.PI*2/12)*i, this.color, this)); } 
                else if(this.type === 'hacker') { this.invul = 60; for(let i=0; i<6; i++) setTimeout(() => projectiles.push(new Projectile(this.x, this.y, Math.random()*Math.PI*2, this.color, this, true)), i*100); } 
                else if(this.type === 'reaper') {
                    this.isDashing = true; this.dashTime = 12; this.dashAngle = this.angle;
                    setTimeout(() => { if(Math.hypot(other.x-this.x, other.y-this.y) < 350) { other.takeDamage(25); other.slowEffect = 60; } }, 150);
                }
            }

            dash() { if(this.dashCD <= 0 && this.isStunned <= 0) { sounds.dash(); this.isDashing = true; this.dashTime = 10; this.dashAngle = this.angle; this.dashCD = 80; } }
            
            takeDamage(a) { 
                if(this.invul > 0) return; sounds.hit(); let finalDmg = a;
                const other = this.id === 1 ? p2 : p1;
                if(this.type === 'shinryu') finalDmg *= 0.85; 
                if(this.type === 'hong' && other.baseDmg > this.baseDmg) finalDmg = a * 0.6;
                this.hp -= finalDmg; this.lastDamageTaken = finalDmg; screenShake = Math.min(20, finalDmg * 1.5); 
                if(this.hp <= 0 && this.hasRebirth) this.triggerRebirth();
            }

            triggerRebirth() {
                this.hasRebirth = false; this.hp = 50; this.invul = 90; screenShake = 40; sounds.skill(800);
                document.getElementById(`p${this.id}-passive-ui`).innerText = 'PASSIVE: REBIRTH [USED]';
                document.getElementById(`p${this.id}-passive-ui`).style.color = '#ff3131';
                const other = this.id === 1 ? p2 : p1;
                if(Math.hypot(other.x-this.x, other.y-this.y) < 400) {
                    const ang = Math.atan2(other.y-this.y, other.x-this.x); other.x += Math.cos(ang) * 200; other.y += Math.sin(ang) * 200; other.takeDamage(15);
                }
                this.isSkillActive = true; this.skillProg = 0;
            }

            draw() {
                // Blackhole Drawing (Refined: Image Only, No Inner Circle, Larger Size, Lower Opacity)
                if(this.blackHoleState) {
                    const bh = this.blackHoleState;
                    const scale = bh.timer > 150 ? (180 - bh.timer)/30 : (bh.timer < 30 ? bh.timer/30 : 1);
                    ctx.save();
                    ctx.translate(bh.x, bh.y);
                    ctx.rotate(Date.now() * 0.005);
                    // 투명도를 낮게 조절 (0.5 이하로 설정하여 몽환적인 느낌 강조)
                    ctx.globalAlpha = scale * 0.45;
                    ctx.shadowBlur = 60; ctx.shadowColor = this.color;
                    // 크기를 더 키움 (기존 220 -> 330)
                    const bhSize = 330 * scale;
                    ctx.drawImage(blackHoleImg, -bhSize/2, -bhSize/2, bhSize, bhSize);
                    ctx.restore();
                }

                // Shinryu Gigantic Dragon Head Draw
                if(this.dragonHeadState) {
                    const ds = this.dragonHeadState;
                    const scale = ds.timer > 120 ? (150 - ds.timer)/30 : (ds.timer < 30 ? ds.timer/30 : 1);
                    const drawWidth = canvas.width * 0.6 * scale;
                    const drawHeight = (dragonImg.height / dragonImg.width) * drawWidth;
                    
                    ctx.save();
                    ctx.translate(canvas.width / 2, canvas.height / 2);
                    ctx.shadowBlur = 50; ctx.shadowColor = this.color;
                    ctx.globalAlpha = scale;
                    
                    // Shake head during roar
                    const hShake = (Math.random() - 0.5) * 20 * scale;
                    ctx.drawImage(dragonImg, -drawWidth/2 + hShake, -drawHeight/2 + hShake, drawWidth, drawHeight);
                    
                    // Additional Glow Effect
                    ctx.globalAlpha = 0.3 * scale;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, drawWidth/2.5, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.restore();
                }

                if(this.nukeState) {
                    const ns = this.nukeState;
                    if(ns.phase === 'track' || ns.phase === 'warn') {
                        ctx.save(); ctx.translate(ns.x, ns.y); ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 4; ctx.setLineDash([10, 5]);
                        ctx.beginPath(); ctx.arc(0, 0, 250, 0, Math.PI*2); ctx.stroke();
                        if(Math.floor(Date.now()/200)%2) { ctx.fillStyle = '#ff0000'; ctx.font = "bold 20px Montserrat"; ctx.textAlign = "center"; ctx.fillText("⚠️ NUCLEAR THREAT ⚠️", 0, -270); }
                        ctx.setLineDash([]); ctx.beginPath(); ctx.moveTo(-300, 0); ctx.lineTo(300, 0); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, -300); ctx.lineTo(0, 300); ctx.stroke();
                        if(ns.timer < 60) { const h = (ns.timer / 60) * 1000; ctx.fillStyle = '#ffcc00'; ctx.shadowBlur = 40; ctx.shadowColor = '#ffcc00'; ctx.beginPath(); ctx.moveTo(-20, -h); ctx.lineTo(20, -h); ctx.lineTo(0, -h+60); ctx.fill(); }
                        ctx.restore();
                    } else if(ns.phase === 'cloud') {
                        ctx.save(); ctx.translate(ns.x, ns.y); const alpha = ns.timer / 60; ctx.globalAlpha = alpha;
                        const stemGrad = ctx.createLinearGradient(0,0,0,-200); stemGrad.addColorStop(0, '#ffcc00'); stemGrad.addColorStop(1, 'transparent');
                        ctx.fillStyle = stemGrad; ctx.fillRect(-40, -200, 80, 200); ctx.shadowBlur = 100; ctx.shadowColor = '#ff3131'; ctx.fillStyle = '#ff3131';
                        for(let i=0; i<8; i++) { const a = (i/8) * Math.PI * 2; ctx.beginPath(); ctx.arc(Math.cos(a)*100, -200 + Math.sin(a)*40, 80, 0, Math.PI*2); ctx.fill(); }
                        ctx.fillStyle = '#ffcc00'; ctx.beginPath(); ctx.ellipse(0, -210, 180, 70, 0, 0, Math.PI*2); ctx.fill(); ctx.restore();
                    }
                }

                ctx.save(); ctx.translate(this.x, this.y); if(this.invul > 0 && Math.floor(Date.now()/50)%2) ctx.globalAlpha = 0.4;
                if(this.isAttacking) {
                    ctx.save(); ctx.rotate(this.angle); const atkColor = (this.type === 'shadow' || this.type === 'reaper' || this.type === 'jingle' || this.type === 'void') ? (this.type === 'jingle' ? '#00ff00' : (this.type === 'void' ? '#ffffff' : '#ff3131')) : this.color;
                    ctx.strokeStyle = atkColor; ctx.lineWidth = 10; ctx.globalAlpha = 1-this.atkProg; ctx.beginPath();
                    if(this.type === 'reaper') { ctx.lineWidth = 15; ctx.arc(0,0, this.range, -1.8, 1.8); ctx.stroke(); ctx.shadowBlur = 40; ctx.shadowColor = '#ff3131'; ctx.beginPath(); ctx.arc(0,0, this.range, -1.2, 1.2); ctx.stroke(); } 
                    else if(this.type === 'hong') { ctx.lineWidth = 15; ctx.arc(0, 0, this.range, -0.5 + (this.atkProg * 1.5), 0.5 + (this.atkProg * 1.5)); ctx.stroke(); } 
                    else if(this.type === 'bulwark') { ctx.lineWidth = 30; ctx.moveTo(this.radius, -20); ctx.lineTo(this.range, -10); ctx.lineTo(this.range, 10); ctx.lineTo(this.radius, 20); ctx.stroke(); } 
                    else if(this.type === 'ez') { ctx.fillStyle = this.color; ctx.fillRect(this.radius + (this.atkProg * 40), -15, 30, 30); } 
                    else if(this.type === 'blade' || this.type === 'shadow' || this.type === 'void') { ctx.arc(0,0, this.range, -1.0, 1.0); ctx.stroke(); } 
                    else if(this.type === 'titan') { ctx.arc(0,0, this.range*this.atkProg, 0, Math.PI*2); ctx.stroke(); } 
                    else if(this.type === 'volt') { ctx.moveTo(0,0); for(let i=1; i<6; i++) ctx.lineTo(i*this.range/5, (Math.random()-0.5)*80); ctx.stroke(); }
                    ctx.restore();
                }

                if(this.isSkillActive && this.type !== 'gangbuk' && this.type !== 'shinryu' && this.type !== 'void') {
                    if(this.type === 'reaper') { ctx.strokeStyle = '#ff3131'; ctx.lineWidth = 15; ctx.globalAlpha = 0.7 * (1-this.skillProg); ctx.beginPath(); ctx.arc(0, 0, 350 * this.skillProg, 0, Math.PI*2); ctx.stroke(); } 
                    else if(this.type === 'jingle') { ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 5; ctx.globalAlpha = 0.5 * (1-this.skillProg); ctx.beginPath(); ctx.arc(0, 0, 400 * this.skillProg, 0, Math.PI*2); ctx.stroke(); } 
                    else if(this.type === 'hong') { ctx.strokeStyle = this.color; ctx.lineWidth = 3; ctx.globalAlpha = 0.5 * (1-this.skillProg); for(let i=1; i<=4; i++) { ctx.beginPath(); ctx.arc(0, 0, i * 100 * this.skillProg, 0, Math.PI*2); ctx.stroke(); } } 
                    else if(this.type === 'bb' || this.type === 'phoenix') { ctx.strokeStyle = this.color; ctx.lineWidth = 20; ctx.globalAlpha = 0.6 * (1-this.skillProg); ctx.beginPath(); ctx.arc(0,0, (this.type === 'phoenix' ? 450 : 400) * this.skillProg, 0, Math.PI*2); ctx.stroke(); } 
                    else if(this.type === 'bulwark') { ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 4; ctx.setLineDash([10, 5]); ctx.beginPath(); ctx.arc(0, 0, 80 + Math.sin(Date.now()/100)*10, 0, Math.PI*2); ctx.stroke(); ctx.setLineDash([]); }
                }

                ctx.rotate(this.angle); ctx.shadowBlur = 30; ctx.shadowColor = this.color; ctx.fillStyle = '#0a0a0a'; ctx.strokeStyle = this.color; ctx.lineWidth = 5;
                ctx.beginPath();
                if(this.type === 'void') {
                    ctx.moveTo(-this.radius, -this.radius/2); ctx.lineTo(this.radius, 0); ctx.lineTo(-this.radius, this.radius/2); ctx.closePath(); ctx.fill(); ctx.stroke();
                    ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.stroke();
                }
                else if(this.type === 'shinryu') {
                    ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius, -this.radius); ctx.lineTo(-this.radius/2, 0); ctx.lineTo(-this.radius, this.radius); ctx.closePath(); ctx.fill(); ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(10, -10, 4, 0, Math.PI*2); ctx.arc(10, 10, 4, 0, Math.PI*2); ctx.fill();
                }
                else if(this.type === 'hanzo') { ctx.moveTo(0, -this.radius); ctx.lineTo(this.radius, 0); ctx.lineTo(0, this.radius); ctx.lineTo(-this.radius, 0); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(0,0, 10, 0, Math.PI*2); ctx.fill(); }
                else if(this.type === 'gangbuk') { ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#000'; ctx.fillRect(0, -10, 20, 10); ctx.fillRect(0, 0, 20, 10); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(5, -8, 10, 6); ctx.strokeRect(5, 2, 10, 6); }
                else if(this.type === 'titan') { const r = this.radius * 1.1; ctx.rect(-r,-r,r*2,r*2); }
                else if(this.type === 'hong') { ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(5, 5); ctx.quadraticCurveTo(15, 15, 25, 5); ctx.stroke(); }
                else if(this.type === 'tamin') { ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle = this.color; ctx.font = "bold 20px Arial"; ctx.fillText("100", -15, 8); }
                else if(this.type === 'jingle') { ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle = '#00ff00'; ctx.font = "bold 24px Arial"; ctx.fillText("🔔", -12, 8); }
                else if(this.type === 'bulwark') { ctx.moveTo(-this.radius, -this.radius); ctx.lineTo(this.radius, -this.radius); ctx.lineTo(this.radius+10, 0); ctx.lineTo(this.radius, this.radius); ctx.lineTo(-this.radius, this.radius); ctx.closePath(); }
                else if(this.type === 'phoenix') { ctx.moveTo(-this.radius, -10); ctx.lineTo(-this.radius-20, -30); ctx.lineTo(this.radius, 0); ctx.lineTo(-this.radius-20, 30); ctx.lineTo(-this.radius, 10); ctx.closePath(); }
                else if(this.type === 'reaper') { ctx.strokeStyle = '#ff3131'; ctx.shadowColor = '#ff3131'; ctx.moveTo(this.radius, 0); ctx.lineTo(0, this.radius); ctx.lineTo(-this.radius, 0); ctx.lineTo(0, -this.radius); ctx.closePath(); }
                else { ctx.arc(0,0, this.radius, 0, Math.PI*2); }
                if(!['ez','hong','tamin','jingle','gangbuk','hanzo','shinryu','void'].includes(this.type)) { ctx.fill(); ctx.stroke(); } else if(['shinryu','hanzo','gangbuk','void'].includes(this.type)) { ctx.fill(); ctx.stroke(); }
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(this.radius-5, -12); ctx.lineTo(this.radius+15, 0); ctx.lineTo(this.radius-5, 12); ctx.fill(); ctx.restore();

                const other = this.id === 1 ? p2 : p1;
                if(this.type === 'tamin' && other.isStunned > 0) { ctx.save(); ctx.translate(other.x, other.y); ctx.strokeStyle = '#5d4037'; ctx.lineWidth = 8; for(let i=0; i<4; i++) { ctx.beginPath(); ctx.rotate(Math.PI/2); ctx.moveTo(0, 50); ctx.quadraticCurveTo(20, 20, 0, 0); ctx.stroke(); ctx.fillStyle = '#228b22'; ctx.beginPath(); ctx.arc(10, 30, 4, 0, Math.PI*2); ctx.fill(); } ctx.restore(); }
                if(this.type === 'jingle' && other.isStunned > 0) { ctx.save(); ctx.translate(other.x, other.y - 60); ctx.fillStyle = '#ffff00'; ctx.font = "bold 30px Arial"; ctx.textAlign = "center"; ctx.fillText("💃 DANCING 🕺", 0, 0); ctx.restore(); }
            }
        }

        class Projectile {
            constructor(x, y, angle, color, owner, isGlitch = false, type = 'orb') {
                this.x = x; this.y = y; this.angle = angle; this.color = color; this.owner = owner; this.isGlitch = isGlitch; this.type = type;
                this.speed = type === 'paper' ? 18 : (type === 'car' ? 22 : (type === 'hog' ? 12 : (type === 'wave' ? 10 : (type === 'fire' ? 12 : (type === 'note' ? 15 : (type === 'gold' ? 20 : (type === 'shuriken' ? 24 : (isGlitch ? 9 : 14)))))))); 
                this.active = true; this.life = type === 'paper' ? 100 : (type === 'car' ? 250 : (type === 'hog' ? 150 : (type === 'fire' ? 40 : (type === 'gold' ? 60 : (type === 'shuriken' ? 50 : 100)))));
            }
            update() {
                this.x += Math.cos(this.angle)*this.speed; this.y += Math.sin(this.angle)*this.speed; if(--this.life <= 0) this.active = false;
                const target = this.owner.id === 1 ? p2 : p1; const d = Math.hypot(this.x-target.x, this.y-target.y);
                const hitRadius = ['car','paper','wave','fire','hog','note','gold','shuriken'].includes(this.type) ? 60 : target.radius + 10;
                if(d < hitRadius) {
                    const dmg = this.type === 'paper' ? 10 : (this.type === 'car' ? 25 : (this.type === 'hog' ? 5 : (this.type === 'wave' ? 8 : (this.type === 'fire' ? 4 : (this.type === 'note' ? 12 : (this.type === 'gold' ? 8 : (this.type === 'shuriken' ? 12 : this.owner.baseDmg * 0.6)))))));
                    target.takeDamage(dmg); if(this.type === 'fire') target.slowEffect = 10;
                    if(!['car','wave','fire','hog'].includes(this.type)) this.active = false; if(['hog','paper','note','gold','shuriken'].includes(this.type)) this.active = false;
                }
            }
            draw() {
                ctx.save(); ctx.shadowBlur = 20; ctx.shadowColor = this.color; ctx.fillStyle = this.color;
                if(this.type === 'shuriken') { ctx.translate(this.x, this.y); ctx.rotate(Date.now()*0.02); ctx.strokeStyle = this.color; ctx.lineWidth = 4; for(let i=0; i<4; i++) { ctx.beginPath(); ctx.rotate(Math.PI/2); ctx.moveTo(0, 0); ctx.lineTo(20, 5); ctx.lineTo(15, 0); ctx.lineTo(20, -5); ctx.closePath(); ctx.fill(); ctx.stroke(); } } 
                else if(this.type === 'paper') { ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#ffffff'; ctx.fillRect(-15, -20, 30, 40); ctx.fillStyle = '#ff0000'; ctx.font = "bold 12px Arial"; ctx.fillText("100", -10, 5); } 
                else if(this.type === 'car') { ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#ff3333'; ctx.fillRect(-60, -30, 120, 60); } 
                else if(this.type === 'gold') { ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#ffcc00'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#fff'; ctx.font = "bold 20px Arial"; ctx.fillText("$", -5, 7); } 
                else if(this.type === 'hog') { ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#6b4226'; ctx.beginPath(); ctx.ellipse(0, 0, 25, 15, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#ffcc99'; ctx.beginPath(); ctx.arc(20, 0, 10, 0, Math.PI*2); ctx.fill(); } 
                else if(this.type === 'note') { ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = (Math.floor(Date.now()/100)%2) ? '#ff0000' : '#00ff00'; ctx.font = "bold 30px Arial"; ctx.fillText("🎵", -15, 10); } 
                else if(this.type === 'wave' || this.type === 'fire') { ctx.globalAlpha = this.life / (this.type === 'fire' ? 40 : 100); ctx.strokeStyle = this.color; ctx.lineWidth = this.type === 'fire' ? 10 : 5; ctx.beginPath(); ctx.arc(this.x, this.y, this.type === 'fire' ? 25 : 40, this.angle - 0.5, this.angle + 0.5); ctx.stroke(); } 
                else { ctx.beginPath(); ctx.arc(this.x, this.y, 7, 0, Math.PI*2); ctx.fill(); } ctx.restore();
            }
        }

        const p1 = new Player(1), p2 = new Player(2);
        let projectiles = [];

        function loop() {
            ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle = '#050505'; ctx.fillRect(0,0,canvas.width,canvas.height);
            if(screenShake > 0) { ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake); screenShake *= 0.9; }

            if(gameActive) {
                p1.velX = 0; p1.velY = 0;
                if(p1.isStunned <= 0) {
                    if(keys['KeyW']) p1.velY = -p1.speed; if(keys['KeyS']) p1.velY = p1.speed; if(keys['KeyA']) p1.velX = -p1.speed; if(keys['KeyD']) p1.velX = p1.speed;
                    if(keys['KeyF']) p1.attack(); if(keys['KeyQ']) p1.dash(); if(keys['KeyE']) p1.useSkill();
                }
                if(gameMode === 'pvp' && p2.isStunned <= 0) {
                    p2.velX = 0; p2.velY = 0;
                    if(keys['ArrowUp']) p2.velY = -p2.speed; if(keys['ArrowDown']) p2.velY = p2.speed; if(keys['ArrowLeft']) p2.velX = -p2.speed; if(keys['ArrowRight']) p2.velX = p2.speed;
                    if(keys['KeyJ']) p2.attack(); if(keys['KeyK']) p2.dash(); if(keys['KeyL']) p2.useSkill();
                }
                timeLeft -= 0.016;
                if(timeLeft <= 0 || p1.hp <= 0 || p2.hp <= 0) {
                    gameActive = false; document.getElementById('game-over').style.display = 'flex';
                    const winT = document.getElementById('winner-text'); const winner = p1.hp > p2.hp ? p1 : p2;
                    winT.innerText = p1.hp > p2.hp ? "P1 VICTORY" : "P2 VICTORY"; winT.style.color = winner.color; winT.style.textShadow = `0 0 40px ${winner.color}`;
                    if(audioCtx) sounds.skill(100);
                }
                document.getElementById('p1-dash-fill').style.height = (p1.dashCD/80)*100 + '%'; document.getElementById('p1-skill-fill').style.height = (p1.skillCD/800)*100 + '%';
                document.getElementById('p2-dash-fill').style.height = (p2.dashCD/80)*100 + '%'; document.getElementById('p2-skill-fill').style.height = (p2.skillCD/800)*100 + '%';
            }

            p1.update(); p2.update(); projectiles = projectiles.filter(p => p.active); projectiles.forEach(p => { p.update(); p.draw(); }); p1.draw(); p2.draw();
            document.getElementById('p1-hp').style.width = Math.max(0, p1.hp) + '%'; document.getElementById('p1-hp').style.backgroundColor = p1.color;
            document.getElementById('p2-hp').style.width = Math.max(0, p2.hp) + '%'; document.getElementById('p2-hp').style.backgroundColor = p2.color;
            document.getElementById('timer').innerText = Math.ceil(timeLeft);
            requestAnimationFrame(loop);
        }
        updateCharUI(1); updateCharUI(2); window.onload = loop;
    </script>
</body>
</html>
