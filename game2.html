<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Arena - Na-Sang-Sa Awakened</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@900&family=Noto+Sans+KR:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f2ff;
            --neon-pink: #ff00ff;
            --neon-yellow: #f0ff00;
            --neon-purple: #bc13fe;
            --neon-orange: #ff8c00;
            --neon-green: #39ff14;
            --neon-red: #ff3131;
            --neon-white: #ffffff;
            --dark-bg: #050505;
        }
        body {
            font-family: 'Noto Sans KR', 'Montserrat', sans-serif;
            background-color: var(--dark-bg);
            color: white;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }
        canvas { display: block; background: #080808; }
        .glass {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.8);
        }
        .bg-grid {
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
            background-size: 60px 60px;
        }
        .stat-bar-bg { width: 100%; height: 8px; background: rgba(255,255,255,0.05); border-radius: 10px; overflow: hidden; }
        .stat-bar-fill { height: 100%; border-radius: 10px; transition: width 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        
        .mode-btn { cursor: pointer; transition: all 0.3s; opacity: 0.3; }
        .mode-btn.active { opacity: 1; transform: scale(1.1); text-shadow: 0 0 15px white; }
        
        .arrow-btn {
            background: rgba(255,255,255,0.05);
            transition: all 0.2s;
            cursor: pointer;
            width: 50px; height: 50px;
            display: flex; align-items: center; justify-content: center;
            border-radius: 50%;
            font-size: 1.2rem;
        }
        .arrow-btn:hover { background: rgba(255,255,255,0.15); transform: scale(1.1); box-shadow: 0 0 15px rgba(255,255,255,0.2); }

        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; padding: 40px; z-index: 10;
        }
        .hp-bar-outer { 
            width: 350px; height: 16px; background: rgba(255, 255, 255, 0.05); 
            border-radius: 20px; overflow: hidden; border: 1px solid rgba(255,255,255,0.1);
        }
        .hp-bar-inner { height: 100%; transition: width 0.2s ease-out; box-shadow: 0 0 20px currentColor; }

        .cd-slot {
            width: 60px; height: 60px; border-radius: 15px;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.7); border: 2px solid rgba(255,255,255,0.1);
            position: relative; overflow: hidden; transition: all 0.3s;
        }
        .cd-fill {
            position: absolute; bottom: 0; left: 0; width: 100%; background: rgba(255,255,255,0.2);
            transition: height 0.1s linear;
        }
        .cd-ready { border-color: white; transform: translateY(-3px); box-shadow: 0 5px 15px rgba(255,255,255,0.15); }

        #game-over {
            position: fixed; inset: 0; background: rgba(0,0,0,0.96);
            display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 1000;
        }
        .btn-round {
            padding: 1.2rem 3rem; border-radius: 100px; font-weight: 900; text-transform: uppercase;
            letter-spacing: 0.1em; transition: all 0.3s; cursor: pointer;
        }
    </style>
</head>
<body class="bg-grid">

    <!-- Lobby Menu -->
    <div id="lobby" class="fixed inset-0 z-[100] flex flex-col items-center justify-between py-16 px-8 bg-black/95">
        <div class="text-center">
            <h1 class="text-6xl font-black italic tracking-tighter mb-4">NEON <span class="text-white/30">ARENA</span></h1>
            <div class="flex gap-10 justify-center mt-6">
                <div onclick="setGameMode('pvp')" id="mode-pvp" class="mode-btn active text-sm font-black tracking-[0.3em] uppercase">PVP DUEL</div>
                <div onclick="setGameMode('pve')" id="mode-pve" class="mode-btn text-sm font-black tracking-[0.3em] uppercase">AI PRACTICE</div>
            </div>
        </div>

        <div class="flex items-center gap-16">
            <!-- P1 Selection -->
            <div class="flex flex-col items-center">
                <div class="text-[10px] font-black tracking-[0.4em] mb-6 opacity-40 uppercase">플레이어 01</div>
                <div class="flex items-center gap-6">
                    <div onclick="prevChar(1)" class="arrow-btn">◀</div>
                    <div id="p1-card" class="glass rounded-[40px] p-8 flex flex-col items-center justify-between w-[320px] h-[420px] border-b-[6px]">
                        <div id="p1-char-code" class="text-7xl font-black italic opacity-10">NB</div>
                        <div class="w-full">
                            <h2 id="p1-char-name" class="text-2xl font-black italic mb-6 text-center tracking-tight">NEON BLADE</h2>
                            <div class="space-y-4" id="p1-stats-container"></div>
                        </div>
                    </div>
                    <div onclick="nextChar(1)" class="arrow-btn">▶</div>
                </div>
            </div>

            <div class="flex flex-col items-center gap-6">
                <div class="text-5xl font-black italic opacity-5 tracking-tighter">VS</div>
                <button onclick="randomizeBoth()" class="glass px-8 py-3 rounded-full text-[11px] font-black hover:bg-white/10 transition tracking-widest uppercase border border-white/10">Randomize</button>
            </div>

            <!-- P2 Selection -->
            <div class="flex flex-col items-center">
                <div class="text-[10px] font-black tracking-[0.4em] mb-6 opacity-40 uppercase text-pink-500">플레이어 02</div>
                <div class="flex items-center gap-6">
                    <div onclick="prevChar(2)" class="arrow-btn">◀</div>
                    <div id="p2-card" class="glass rounded-[40px] p-8 flex flex-col items-center justify-between w-[320px] h-[420px] border-b-[6px]">
                        <div id="p2-char-code" class="text-7xl font-black italic opacity-10">CS</div>
                        <div class="w-full">
                            <h2 id="p2-char-name" class="text-2xl font-black italic mb-6 text-center tracking-tight">CYBER STING</h2>
                            <div class="space-y-4" id="p2-stats-container"></div>
                        </div>
                    </div>
                    <div onclick="nextChar(2)" class="arrow-btn">▶</div>
                </div>
            </div>
        </div>

        <button onclick="startGame()" class="btn-round bg-white text-black hover:scale-110 active:scale-95 shadow-[0_0_30px_rgba(255,255,255,0.3)]">Engage Protocol</button>
    </div>

    <!-- In-game UI -->
    <div id="ingame-ui" class="ui-layer hidden">
        <div class="flex justify-between items-start">
            <div class="flex flex-col gap-2">
                <div id="p1-name-ui" class="text-xl font-black italic tracking-tighter uppercase">P1</div>
                <div class="hp-bar-outer"><div id="p1-hp" class="hp-bar-inner"></div></div>
                <div id="p1-passive-ui" class="text-[10px] font-black opacity-60"></div>
            </div>
            <div class="text-center">
                <div id="timer" class="text-5xl font-black italic opacity-20 tracking-tighter">99</div>
            </div>
            <div class="flex flex-col items-end gap-2">
                <div id="p2-name-ui" class="text-xl font-black italic tracking-tighter text-right uppercase">P2</div>
                <div class="hp-bar-outer"><div id="p2-hp" class="hp-bar-inner"></div></div>
                <div id="p2-passive-ui" class="text-[10px] font-black opacity-60"></div>
            </div>
        </div>

        <div class="fixed bottom-10 left-0 right-0 flex justify-between px-20 pointer-events-none">
            <div class="flex gap-4 items-center">
                <div id="p1-dash-slot" class="cd-slot">
                    <div id="p1-dash-fill" class="cd-fill"></div>
                    <span class="text-[10px] font-black z-10">DASH</span>
                    <span class="text-[8px] opacity-40 z-10 font-bold">Q</span>
                </div>
                <div id="p1-skill-slot" class="cd-slot">
                    <div id="p1-skill-fill" class="cd-fill"></div>
                    <span class="text-[10px] font-black z-10">SKILL</span>
                    <span class="text-[8px] opacity-40 z-10 font-bold">E</span>
                </div>
                <div class="ml-2 text-left">
                    <div class="text-[10px] font-black opacity-30 uppercase">P1 Status</div>
                    <div id="p1-char-label" class="text-xs font-black italic tracking-tighter">READY</div>
                </div>
            </div>

            <div class="flex gap-4 items-center flex-row-reverse">
                <div id="p2-dash-slot" class="cd-slot">
                    <div id="p2-dash-fill" class="cd-fill"></div>
                    <span class="text-[10px] font-black z-10">DASH</span>
                    <span class="text-[8px] opacity-40 z-10 font-bold">K</span>
                </div>
                <div id="p2-skill-slot" class="cd-slot">
                    <div id="p2-skill-fill" class="cd-fill"></div>
                    <span class="text-[10px] font-black z-10">SKILL</span>
                    <span class="text-[8px] opacity-40 z-10 font-bold">L</span>
                </div>
                <div class="mr-2 text-right">
                    <div class="text-[10px] font-black opacity-30 uppercase">P2 Status</div>
                    <div id="p2-char-label" class="text-xs font-black italic tracking-tighter">READY</div>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over">
        <h2 id="winner-text" class="text-8xl font-black italic mb-10 tracking-tighter uppercase">TERMINATED</h2>
        <button onclick="goToMenu()" class="btn-round border-2 border-white/20 hover:border-white text-white">Return to Base</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const dragonImg = new Image();
        dragonImg.src = 'https://i.ifh.cc/pPrAjV.png';
        const blackHoleImg = new Image();
        blackHoleImg.src = 'https://i.ifh.cc/NWTLPJ.png';
        const nasangsaSharkImg = new Image();
        nasangsaSharkImg.src = 'https://i.ifh.cc/M2dnST.png';

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) audioCtx = new AudioContext();
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        const sounds = {
            attack: (freq = 150) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            },
            hit: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.15);
            },
            dash: () => {
                const noise = audioCtx.createBufferSource();
                const bufferSize = audioCtx.sampleRate * 0.1;
                const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                const data = buffer.getChannelData(0);
                for(let i=0; i<bufferSize; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;
                const filter = audioCtx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                const gain = audioCtx.createGain();
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                noise.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
                noise.start();
            },
            skill: (f = 440) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(f, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(f * 2, audioCtx.currentTime + 0.3);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            },
            bell: () => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(987.77, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                osc.connect(gain); gain.connect(audioCtx.destination);
                osc.start(); osc.stop(audioCtx.currentTime + 0.5);
            }
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let gameActive = false;
        let gameMode = 'pvp';
        let timeLeft = 99;
        let screenShake = 0;
        let mouseX = 0, mouseY = 0;
        const keys = {};

        // --- 캐릭터 데이터 베이스 ---
        const CHARS = [
            { id: 'nasangsa', name: '나상사', code: 'NSS', color: '#00ccff', speed: 8.0, damage: 22, range: 450, stats: { spd: 90, dmg: 95, rng: 100 } },
            { id: 'neonslime', name: 'NEON SLIME', code: 'NS', color: '#88ff00', speed: 5.0, damage: 18, range: 300, stats: { spd: 40, dmg: 90, rng: 75 } },
            { id: 'aurora', name: 'COSMIC AURORA', code: 'CA', color: '#00ffd4', speed: 6.8, damage: 14, range: 420, stats: { spd: 65, dmg: 85, rng: 95 } },
            { id: 'glitch', name: 'PIXEL GLITCH', code: 'PG', color: '#ff00ff', speed: 7.2, damage: 13, range: 450, stats: { spd: 80, dmg: 70, rng: 100 } },
            { id: 'witch', name: 'NEON WITCH', code: 'NW', color: '#bf00ff', speed: 6.2, damage: 12, range: 380, stats: { spd: 65, dmg: 75, rng: 95 } },
            { id: 'void', name: 'VOID REAPER', code: 'VR', color: '#4a00e0', speed: 6.5, damage: 14, range: 220, stats: { spd: 70, dmg: 85, rng: 80 } },
            { id: 'shinryu', name: 'SHINRYU', code: 'SR', color: '#ff0055', speed: 7.2, damage: 16, range: 180, stats: { spd: 75, dmg: 95, rng: 85 } },
            { id: 'hanzo', name: 'HANZO', code: 'HZ', color: '#00ffcc', speed: 8.5, damage: 10, range: 350, stats: { spd: 95, dmg: 55, rng: 90 } },
            { id: 'gangbuk', name: 'GANGBUK', code: 'GB', color: '#ffcc00', speed: 6.8, damage: 15, range: 160, stats: { spd: 70, dmg: 85, rng: 65 } },
            { id: 'dragon', name: 'GANGBUK DRAGON', code: 'GD', color: '#ff4d00', speed: 6.5, damage: 18, range: 250, stats: { spd: 65, dmg: 90, rng: 85 } },
            { id: 'ghost', name: 'BLUE GHOST', code: 'BG', color: '#00e5ff', speed: 8.0, damage: 14, range: 160, stats: { spd: 95, dmg: 75, rng: 60 } },
            { id: 'blood', name: 'BLOOD MOON', code: 'BM', color: '#ff0033', speed: 6.8, damage: 17, range: 450, stats: { spd: 65, dmg: 95, rng: 100 } },
            { id: 'cybersamurai', name: 'CYBER SAMURAI', code: 'CS2', color: '#ffea00', speed: 7.5, damage: 15, range: 320, stats: { spd: 85, dmg: 80, rng: 85 } },
            { id: 'cybernecromancer', name: 'CYBER NECRO', code: 'CN', color: '#00ff66', speed: 6.3, damage: 13, range: 420, stats: { spd: 60, dmg: 70, rng: 100 } },
            { id: 'crystalsummoner', name: 'CRYSTAL SUMMONER', code: 'KC', color: '#00ffff', speed: 6.4, damage: 12, range: 400, stats: { spd: 65, dmg: 75, rng: 95 } },
            { id: 'blade', name: 'NEON BLADE', code: 'NB', color: '#00f2ff', speed: 7.0, damage: 12, range: 140, stats: { spd: 80, dmg: 60, rng: 60 } },
            { id: 'sting', name: 'CYBER STING', code: 'CS', color: '#ff00ff', speed: 7.8, damage: 7, range: 280, stats: { spd: 90, dmg: 40, rng: 100 } },
            { id: 'volt', name: 'VOLT STRIKER', code: 'VS', color: '#f0ff00', speed: 6.5, damage: 13, range: 180, stats: { spd: 75, dmg: 65, rng: 80 } },
            { id: 'shadow', name: 'SHADOW PHANTOM', code: 'SP', color: '#bc13fe', speed: 8.2, damage: 15, range: 120, stats: { spd: 100, dmg: 75, rng: 45 } },
            { id: 'phoenix', name: 'PHOENIX WING', code: 'PW', color: '#ff4d00', speed: 7.5, damage: 8, range: 220, stats: { spd: 85, dmg: 40, rng: 85 } },
            { id: 'hong', name: 'HONG AJEO-SSI', code: 'HG', color: '#8b4513', speed: 6.0, damage: 11, range: 130, stats: { spd: 55, dmg: 55, rng: 50 } },
            { id: 'tamin', name: 'TAMIN-RATATA', code: 'TM', color: '#2ecc71', speed: 6.8, damage: 10, range: 400, stats: { spd: 70, dmg: 90, rng: 95 } },
            { id: 'jingle', name: 'JINGLE-BELL ROCK', code: 'JR', color: '#ff2e2e', speed: 7.1, damage: 11, range: 300, stats: { spd: 75, dmg: 60, rng: 85 } },
            { id: 'titan', name: 'GRAVITY TITAN', code: 'GT', color: '#ff8c00', speed: 5.5, damage: 18, range: 170, stats: { spd: 40, dmg: 85, rng: 75 } },
            { id: 'bulwark', name: 'IRON BULWARK', code: 'IB', color: '#94a3b8', speed: 4.8, damage: 20, range: 150, stats: { spd: 30, dmg: 95, rng: 55 } },
            { id: 'hacker', name: 'GLITCH HACKER', code: 'GH', color: '#39ff14', speed: 7.4, damage: 14, range: 220, stats: { spd: 85, dmg: 70, rng: 90 } },
            { id: 'reaper', name: 'PLASMA REAPER', code: 'PR', color: '#ff3131', speed: 6.2, damage: 14, range: 200, stats: { spd: 65, dmg: 70, rng: 85 } },
            { id: 'ez', name: 'ALPANOZIAN', code: 'EZ', color: '#ffffff', speed: 7.2, damage: 13, range: 110, stats: { spd: 80, dmg: 65, rng: 50 } },
            { id: 'bb', name: 'BEAT BREAKER', code: 'BB', color: '#00ffaa', speed: 7.0, damage: 12, range: 240, stats: { spd: 75, dmg: 60, rng: 85 } },
            { id: 'pig', name: 'PIG WOO', code: 'PW', color: '#ff85a1', speed: 5.2, damage: 22, range: 140, stats: { spd: 35, dmg: 95, rng: 40 } }
        ];

        let p1Idx = 0, p2Idx = 1;

        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);
        window.addEventListener('mousemove', e => { mouseX = e.clientX; mouseY = e.clientY; });
        window.addEventListener('mousedown', e => { 
            initAudio();
            if(!gameActive || gameMode !== 'pve') return;
            if(e.button === 0) p1.attack();
            if(e.button === 2) p1.useSkill();
        });
        window.addEventListener('contextmenu', e => e.preventDefault());

        function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize); resize();

        function setGameMode(mode) {
            gameMode = mode;
            document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
            document.getElementById('mode-' + mode).classList.add('active');
        }

        function updateCharUI(pNum) {
            const idx = pNum === 1 ? p1Idx : p2Idx;
            const data = CHARS[idx];
            const prefix = pNum === 1 ? 'p1' : 'p2';
            const card = document.getElementById(`${prefix}-card`);
            card.style.borderBottomColor = data.color;
            document.getElementById(`${prefix}-char-code`).innerText = data.code;
            document.getElementById(`${prefix}-char-code`).style.color = data.color;
            document.getElementById(`${prefix}-char-name`).innerText = data.name;
            document.getElementById(`${prefix}-char-name`).style.color = data.color;
            
            const container = document.getElementById(`${prefix}-stats-container`);
            container.innerHTML = '';
            ['spd', 'dmg', 'rng'].forEach(s => {
                container.innerHTML += `
                    <div>
                        <div class="flex justify-between text-[10px] font-black mb-2 opacity-40"><span>${s.toUpperCase()}</span><span>${data.stats[s]}</span></div>
                        <div class="stat-bar-bg"><div class="stat-bar-fill shadow-[0_0_10px_${data.color}]" style="width: ${data.stats[s]}%; background: ${data.color}"></div></div>
                    </div>`;
            });
        }

        function nextChar(pNum) { if(pNum === 1) p1Idx = (p1Idx+1)%CHARS.length; else p2Idx = (p2Idx+1)%CHARS.length; updateCharUI(pNum); }
        function prevChar(pNum) { if(pNum === 1) p1Idx = (p1Idx-1+CHARS.length)%CHARS.length; else p2Idx = (p2Idx-1+CHARS.length)%CHARS.length; updateCharUI(pNum); }
        function randomizeBoth() { 
            p1Idx = Math.floor(Math.random()*CHARS.length); 
            p2Idx = Math.floor(Math.random()*CHARS.length); 
            updateCharUI(1); updateCharUI(2); 
        }

        function startGame() {
            initAudio();
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('ingame-ui').classList.remove('hidden');
            p1.init(p1Idx, 400, canvas.height/2);
            p2.init(p2Idx, canvas.width - 400, canvas.height/2);
            document.getElementById('p1-name-ui').innerText = p1.name;
            document.getElementById('p1-name-ui').style.color = p1.color;
            document.getElementById('p2-name-ui').innerText = p2.name;
            document.getElementById('p2-name-ui').style.color = p2.color;
            document.getElementById('p1-char-label').innerText = p1.name;
            document.getElementById('p2-char-label').innerText = p2.name;
            document.getElementById('p1-passive-ui').innerText = getPassiveText(p1);
            document.getElementById('p2-passive-ui').innerText = getPassiveText(p2);
            gameActive = true; timeLeft = 99;
            projectiles = [];
        }

        function getPassiveText(p) {
            if(p.type === 'nasangsa') return '패시브: 나약한 영혼 (받는 피해량 증가, 투사체 속도 최상)';
            if(p.type === 'neonslime') return '패시브: 점액질 파편 (적중 시 일정 시간 장판 생성)';
            if(p.type === 'aurora') return '패시브: 우주의 가호 (스킬 시전 시 강력한 중력장 및 거대 별똥별 낙하)';
            if(p.type === 'glitch') return '패시브: 시스템 오류 (공격 명중 시 적 이동 차단)';
            if(p.type === 'witch') return '패시브: 마력 증폭 (스킬 시전 중 방어력 상승)';
            if(p.type === 'void') return '패시브: 공포의 심연 (공격 시 이동속도 감소)';
            if(p.type === 'shinryu') return '패시브: 신룡의 비늘 (상시 데미지 감소)';
            if(p.type === 'dragon') return '패시브: 용의 격노 (스킬 피해 강화)';
            if(p.type === 'ghost') return '패시브: 영혼의 형체 (기동성 특화)';
            if(p.type === 'blood') return '패시브: 붉은 달의 가호 (광역 공격 특화)';
            if(p.type === 'cybersamurai') return '패시브: 강철의 의지 (균형잡힌 스탯)';
            if(p.type === 'cybernecromancer') return '패시브: 영혼 추적 (공격 유도 성능)';
            if(p.type === 'crystalsummoner') return '패시브: 수정 응축 (지속적인 마력 충전)';
            if(p.type === 'hanzo') return '패시브: 그림자 걸음 (기본 속도 최상)';
            if(p.type === 'gangbuk') return '패시브: 선글라스의 위엄 (반사 광채)';
            if(p.type === 'phoenix') return '패시브: 부활 [준비됨]';
            if(p.type === 'hong') return '패시브: 연륜의 여유 (데미지 경감)';
            if(p.type === 'tamin') return '패시브: 쮠똬 (회피 확률 증가)';
            if(p.type === 'jingle') return '패시브: 리드미컬 징글';
            if(p.type === 'pig') return '패시브: 지방질 장갑 (방어력 증가)';
            return '';
        }

        function goToMenu() {
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('lobby').style.display = 'flex';
            document.getElementById('ingame-ui').classList.add('hidden');
            gameActive = false;
        }

        class Player {
            constructor(id) {
                this.id = id; this.radius = 35; this.hp = 100;
            }
            init(idx, x, y) {
                const d = CHARS[idx];
                this.type = d.id; this.name = d.name; this.color = d.color;
                this.speed = d.speed; this.baseDmg = d.damage; this.range = d.range;
                this.x = x; this.y = y; this.hp = 100; this.angle = this.id === 1 ? 0 : Math.PI;
                this.dashCD = 0; this.skillCD = 0; this.attackCD = 0;
                this.isAttacking = false; this.isSkillActive = false; this.isDashing = false;
                this.invul = 0; this.slowEffect = 0;
                this.lastDamageTaken = 0;
                this.hasRebirth = (this.type === 'phoenix');
                this.isStunned = 0;
                this.nukeState = null;
                this.dragonHeadState = null;
                this.blackHoleState = null;
                this.magicFieldState = null;
                this.meteorState = null; 
                this.glitchFrame = 0;
                this.sharkBiteState = null;
            }

            update() {
                if(!gameActive) return;
                if(this.dashCD > 0) this.dashCD--;
                if(this.skillCD > 0) this.skillCD--;
                if(this.attackCD > 0) this.attackCD--;
                if(this.invul > 0) this.invul--;
                if(this.slowEffect > 0) this.slowEffect--;
                if(this.isStunned > 0) this.isStunned--;
                this.glitchFrame++;

                if(this.meteorState) {
                    this.meteorState.timer--;
                    if(this.meteorState.timer > 0) {
                        this.meteorState.currentX += this.meteorState.vx;
                        this.meteorState.currentY += this.meteorState.vy;
                        if(this.meteorState.timer === 20) {
                            const target = this.id === 1 ? p2 : p1;
                            const d = Math.hypot(target.x - this.meteorState.targetX, target.y - this.meteorState.targetY);
                            if(d < 300) { target.takeDamage(35); target.isStunned = 60; }
                            screenShake = 100; sounds.attack(80);
                        }
                    } else { this.meteorState = null; }
                }

                if(this.magicFieldState) {
                    this.magicFieldState.timer--;
                    const target = this.id === 1 ? p2 : p1;
                    const mf = this.magicFieldState;
                    const d = Math.hypot(target.x - mf.x, target.y - mf.y);
                    if(mf.timer > 0) {
                        if(['aurora', 'witch', 'cybernecromancer', 'crystalsummoner', 'glitch', 'neonslime'].includes(this.type)) this.invul = 2;
                        if(d < 250) {
                            const ang = Math.atan2(mf.y - target.y, mf.x - target.x);
                            target.x += Math.cos(ang) * 4; target.y += Math.sin(ang) * 4;
                            if(mf.timer % 20 === 0) target.takeDamage(2);
                        }
                    } else { this.magicFieldState = null; this.isSkillActive = false; }
                }

                if(this.blackHoleState) {
                    this.blackHoleState.timer--;
                    const target = this.id === 1 ? p2 : p1;
                    const bh = this.blackHoleState;
                    const d = Math.hypot(target.x - bh.x, target.y - bh.y);
                    if(bh.timer > 0) {
                        const tornadoRadius = this.type === 'nasangsa' ? 1000 : 350; // 나상사는 3배 이상
                        if(d < tornadoRadius) {
                            // 토네이도 물리 효과 (회전 + 인력)
                            const angToBH = Math.atan2(bh.y - target.y, bh.x - target.x);
                            const orbitalAng = angToBH + Math.PI / 2; // 직각 방향으로 회전
                            
                            const pullStrength = this.type === 'nasangsa' ? 10 : 6;
                            const spinStrength = this.type === 'nasangsa' ? 8 : 0;

                            target.x += Math.cos(angToBH) * pullStrength + Math.cos(orbitalAng) * spinStrength;
                            target.y += Math.sin(angToBH) * pullStrength + Math.sin(orbitalAng) * spinStrength;
                            
                            if(bh.timer % 15 === 0) target.takeDamage(this.type === 'nasangsa' ? 3 : 1.5);
                        }
                        
                        // 나상사 전용 피니쉬 로직
                        if(this.type === 'nasangsa' && bh.timer === 40) {
                            this.sharkBiteState = { x: bh.x, y: bh.y, timer: 40 };
                            sounds.skill(50);
                        }
                        if(this.type === 'nasangsa' && bh.timer === 1) {
                            if(d < 200) {
                                target.takeDamage(999); // 한방 컷
                                screenShake = 200;
                            }
                        }
                    } else { 
                        this.blackHoleState = null; 
                        this.isSkillActive = false; 
                    }
                }

                if(this.sharkBiteState) {
                    this.sharkBiteState.timer--;
                    if(this.sharkBiteState.timer <= 0) this.sharkBiteState = null;
                }

                if(this.dragonHeadState) {
                    this.dragonHeadState.timer--;
                    if(this.dragonHeadState.timer <= 0) { this.dragonHeadState = null; this.isSkillActive = false; } 
                    else if(this.dragonHeadState.timer === 70) {
                        const target = this.id === 1 ? p2 : p1;
                        target.takeDamage(45); target.isStunned = 120; screenShake = 120;
                    }
                }

                if(this.nukeState) {
                    this.nukeState.timer--;
                    const target = this.id === 1 ? p2 : p1;
                    if(this.nukeState.phase === 'track') {
                        this.nukeState.x = target.x; this.nukeState.y = target.y;
                        if(this.nukeState.timer <= 60) this.nukeState.phase = 'warn'; 
                    } else if(this.nukeState.phase === 'warn') {
                        if(this.nukeState.timer <= 0) { this.nukeState.phase = 'impact'; this.triggerNukeImpact(); }
                    }
                }

                const other = this.id === 1 ? p2 : p1;
                if(gameMode === 'pve' && this.id === 1) this.angle = Math.atan2(mouseY-this.y, mouseX-this.x);
                else this.angle = Math.atan2(other.y-this.y, other.x-this.x);

                if(this.isStunned > 0) return;

                if(this.isDashing) {
                    const dSpeed = this.type === 'ghost' ? 38 : 32;
                    this.x += Math.cos(this.dashAngle)*dSpeed; this.y += Math.sin(this.dashAngle)*dSpeed;
                    if(--this.dashTime <= 0) this.isDashing = false;
                    if((this.type === 'ghost' || this.type === 'blade') && this.isSkillActive) {
                        const dToTarget = Math.hypot(this.x - other.x, this.y - other.y);
                        if(dToTarget < 100) { other.takeDamage(this.type === 'ghost' ? 15 : 25); this.isSkillActive = false; }
                    }
                } else {
                    this.x += (this.velX || 0) * (this.slowEffect > 0 ? 0.3 : 1); 
                    this.y += (this.velY || 0) * (this.slowEffect > 0 ? 0.3 : 1);
                }

                if(this.isAttacking && (this.atkProg += 0.2) >= 1) this.isAttacking = false;
                if(this.isSkillActive && (this.skillProg += 0.01) >= 1) this.isSkillActive = false;

                if(this.type === 'titan' && this.isSkillActive) {
                    const d = Math.hypot(other.x-this.x, other.y-this.y);
                    if(d < 500) { other.x += (this.x - other.x) * 0.12; other.y += (this.y - other.y) * 0.12; }
                }
                if(this.type === 'bulwark' && this.isSkillActive) {
                    this.invul = 5; 
                    const d = Math.hypot(other.x-this.x, other.y-this.y);
                    if(d < 250 && Math.random() < 0.1) other.takeDamage(1.5);
                }
                if(this.type === 'pig' && this.isSkillActive) {
                    this.x += Math.cos(this.angle) * 15; this.y += Math.sin(this.angle) * 15;
                    const d = Math.hypot(other.x - this.x, other.y - this.y);
                    if(d < 70) {
                        other.takeDamage(2); other.x += Math.cos(this.angle) * 20; other.y += Math.sin(this.angle) * 20;
                    }
                }

                this.x = Math.max(this.radius, Math.min(canvas.width-this.radius, this.x));
                this.y = Math.max(this.radius, Math.min(canvas.height-this.radius, this.y));
                if(gameMode === 'pve' && this.id === 2) this.updateAI();
            }

            triggerNukeImpact() {
                const other = this.id === 1 ? p2 : p1;
                sounds.attack(50); screenShake = 60;
                const d = Math.hypot(other.x - this.nukeState.x, other.y - this.nukeState.y);
                if(d < 250) { other.takeDamage(45); other.isStunned = 60; }
                this.nukeState.phase = 'cloud'; this.nukeState.timer = 60; 
                setTimeout(() => { this.nukeState = null; this.isSkillActive = false; }, 1000);
            }

            updateAI() {
                const other = p1;
                const d = Math.hypot(other.x-this.x, other.y-this.y);
                const idealDist = this.range * 0.8;
                if(d > idealDist + 20) { this.velX = Math.cos(this.angle)*this.speed; this.velY = Math.sin(this.angle)*this.speed; }
                else if(d < idealDist - 50) { this.velX = -Math.cos(this.angle)*this.speed; this.velY = -Math.sin(this.angle)*this.speed; }
                else {
                    this.velX = Math.cos(this.angle + Math.PI/2) * (Math.sin(Date.now()/500) * 4);
                    this.velY = Math.sin(this.angle + Math.PI/2) * (Math.sin(Date.now()/500) * 4);
                    this.attack(); 
                }
                if(d < 400 && Math.random() < 0.02) this.useSkill();
                if(d < 150 && Math.random() < 0.05) this.dash();
            }

            attack() {
                if(this.attackCD > 0 || this.isDashing || this.isStunned > 0) return;
                this.isAttacking = true; this.atkProg = 0; this.attackCD = 22;
                if(this.type === 'jingle') sounds.bell(); else sounds.attack(150 + Math.random()*100);

                const other = this.id === 1 ? p2 : p1;
                
                if(this.type === 'nasangsa') projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'magic'));
                else if(this.type === 'volt') {
                    projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'lightning'));
                    const d = Math.hypot(other.x-this.x, other.y-this.y);
                    if(d < this.range) other.takeDamage(this.baseDmg);
                }
                else if(this.type === 'neonslime') projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'orb'));
                else if(this.type === 'aurora') projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'star'));
                else if(this.type === 'glitch') projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'cube'));
                else if(['witch', 'cybernecromancer', 'crystalsummoner'].includes(this.type)) projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'magic'));
                else if(['shinryu', 'dragon', 'ghost', 'blood', 'cybersamurai'].includes(this.type)) {
                    const count = (this.type === 'dragon' || this.type === 'ghost') ? 1 : 3;
                    const pType = (this.type === 'ghost') ? 'orb' : (this.type === 'blood' ? 'blood_orb' : (this.type === 'cybersamurai' ? 'wave' : 'fire'));
                    for(let i=0; i<count; i++) projectiles.push(new Projectile(this.x, this.y, this.angle + (Math.random()-0.5)*0.3, this.color, this, false, pType));
                } else if(this.type === 'hanzo') projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'shuriken'));
                else if(this.type === 'gangbuk') projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'gold'));
                else if(this.type === 'tamin') {
                    this.attackCD = 100;
                    for(let i=0; i<20; i++) setTimeout(() => { if(!gameActive) return; projectiles.push(new Projectile(this.x, this.y, this.angle + (Math.random()-0.5)*0.1, this.color, this, false, 'paper')); }, i * 30);
                } else if(['jingle', 'sting', 'hacker', 'bb', 'phoenix'].includes(this.type)) {
                    if(this.type === 'phoenix') { for(let i=-1; i<=1; i++) projectiles.push(new Projectile(this.x, this.y, this.angle + i*0.2, this.color, this, false, 'fire')); } 
                    else { projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, this.type === 'hacker', this.type === 'bb' ? 'wave' : (this.type === 'jingle' ? 'note' : 'orb'))); }
                } else {
                    const d = Math.hypot(other.x-this.x, other.y-this.y);
                    const angTo = Math.atan2(other.y-this.y, other.x-this.x);
                    let diff = Math.abs(this.angle - angTo);
                    if(diff > Math.PI) diff = 2*Math.PI-diff;
                    if(d < this.range && diff < 0.8) {
                        let finalDmg = this.baseDmg;
                        if(this.type === 'ez') {
                            if(this.baseDmg > other.baseDmg) finalDmg *= 1.15; else if(this.baseDmg < other.baseDmg) finalDmg *= 0.9;
                            finalDmg += this.lastDamageTaken * 0.05; this.lastDamageTaken = 0;
                        }
                        if(this.type === 'void') other.slowEffect = 60;
                        other.takeDamage(finalDmg);
                        screenShake = (['titan', 'reaper', 'bulwark', 'hong', 'void', 'ez', 'pig'].includes(this.type)) ? 15 : 8;
                    }
                }
            }

            useSkill() {
                if(this.skillCD > 0 || this.isStunned > 0) return;
                this.skillCD = 800; this.isSkillActive = true; this.skillProg = 0;
                const other = this.id === 1 ? p2 : p1;
                
                if(this.type === 'nasangsa') {
                    sounds.skill(100); screenShake = 40; 
                    // 지속 시간 3배 (120 -> 360)
                    this.blackHoleState = { x: other.x, y: other.y, timer: 360 }; return;
                }
                if(this.type === 'neonslime') { sounds.skill(400); screenShake = 30; this.magicFieldState = { x: this.x, y: this.y, timer: 300 }; return; }
                if(this.type === 'aurora') {
                    sounds.skill(1800); screenShake = 40;
                    this.magicFieldState = { x: other.x, y: other.y, timer: 250 }; 
                    const startX = other.x + 800; const startY = other.y - 1000;
                    this.meteorState = { targetX: other.x, targetY: other.y, currentX: startX, currentY: startY, timer: 100, vx: (other.x - startX) / 80, vy: (other.y - startY) / 80 };
                    return;
                }
                if(this.type === 'glitch') { sounds.skill(2000); screenShake = 45; this.magicFieldState = { x: other.x, y: other.y, timer: 180 }; return; }
                if(this.type === 'crystalsummoner') { sounds.skill(1200); screenShake = 35; this.magicFieldState = { x: other.x, y: other.y, timer: 220 }; return; }
                if(this.type === 'cybernecromancer') { sounds.skill(600); screenShake = 30; this.magicFieldState = { x: other.x, y: other.y, timer: 200 }; return; }
                if(this.type === 'cybersamurai') {
                    sounds.skill(1000); screenShake = 40;
                    for(let i=0; i<8; i++) setTimeout(() => { if(!gameActive) return; projectiles.push(new Projectile(this.x, this.y, this.angle + (Math.random()-0.5)*0.5, this.color, this, false, 'wave')); }, i * 60);
                    return;
                }
                if(this.type === 'ghost') { sounds.skill(800); this.isDashing = true; this.dashTime = 12; this.dashAngle = this.angle; this.invul = 30; return; }
                if(this.type === 'blood') {
                    sounds.skill(200); screenShake = 50;
                    for(let i=0; i<5; i++) setTimeout(() => { if(!gameActive) return; projectiles.push(new Projectile(this.x, this.y, this.angle + (i-2)*0.1, this.color, this, false, 'blood_surge')); }, i * 100);
                    return;
                }
                if(this.type === 'witch') { sounds.skill(600); screenShake = 20; this.magicFieldState = { x: other.x, y: other.y, timer: 180 }; return; }
                if(this.type === 'void') { sounds.skill(100); screenShake = 40; this.blackHoleState = { x: other.x, y: other.y, timer: 180 }; return; }
                if(this.type === 'shinryu') { sounds.skill(80); screenShake = 80; this.dragonHeadState = { timer: 150 }; return; }
                if(this.type === 'dragon') {
                    sounds.skill(500); screenShake = 40;
                    for(let i=0; i<3; i++) setTimeout(() => { if(!gameActive) return; projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'dragon_breath')); }, i * 150);
                    return;
                }
                if(this.type === 'hanzo') {
                    sounds.skill(600); this.invul = 60;
                    [0, Math.PI/2, Math.PI, Math.PI*1.5].forEach(ang => { const sx = other.x + Math.cos(ang) * 200; const sy = other.y + Math.sin(ang) * 200; projectiles.push(new Projectile(sx, sy, Math.atan2(other.y - sy, other.x - sx), this.color, this, false, 'shuriken')); });
                    return;
                }
                if(this.type === 'gangbuk') { sounds.skill(200); this.nukeState = { phase: 'track', x: other.x, y: other.y, timer: 180 }; return; }
                if(this.type === 'jingle') {
                    sounds.bell(); other.isStunned = 180; other.skillCD = 180;
                    const danceTimer = setInterval(() => { if(!gameActive || other.isStunned <= 0) { clearInterval(danceTimer); return; } other.x += (Math.random() - 0.5) * 10; other.y += (Math.random() - 0.5) * 10; }, 50);
                    setTimeout(() => clearInterval(danceTimer), 3000); return;
                }
                if(this.type === 'tamin') {
                    sounds.skill(150); const tX = other.x, tY = other.y; other.isStunned = 120;
                    const bindTimer = setInterval(() => { if(!gameActive || other.isStunned <= 0) { clearInterval(bindTimer); return; } other.takeDamage(1); other.x = tX; other.y = tY; }, 50);
                    setTimeout(() => clearInterval(bindTimer), 2000);
                } else if(this.type === 'hong') {
                    sounds.skill(300); screenShake = 35; if(Math.hypot(other.x-this.x, other.y-this.y) < 400) other.slowEffect = 180;
                    for(let i=0; i<8; i++) setTimeout(() => { if(!gameActive) return; let sx, sy, side = Math.floor(Math.random() * 4); if(side === 0) { sx = 0; sy = Math.random()*canvas.height; } else if(side === 1) { sx = canvas.width; sy = Math.random()*canvas.height; } else if(side === 2) { sx = Math.random()*canvas.width; sy = 0; } else { sx = Math.random()*canvas.width; sy = canvas.height; } projectiles.push(new Projectile(sx, sy, Math.atan2(other.y - sy, other.x - sx), '#ffcc00', this, false, 'hog')); }, i * 250);
                } else if(this.type === 'phoenix') {
                    sounds.skill(500); screenShake = 30; if(Math.hypot(other.x-this.x, other.y-this.y) < 450) { other.takeDamage(22); const ang = Math.atan2(other.y-this.y, other.x-this.x); other.x += Math.cos(ang) * 150; other.y += Math.sin(ang) * 150; other.slowEffect = 60; projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'fire')); }
                } else if(this.type === 'bulwark') {
                    this.invul = 150; sounds.skill(200);
                    const pulse = setInterval(() => { if(this.skillProg >= 1) clearInterval(pulse); if(Math.hypot(other.x-this.x, other.y-this.y) < 300) { const ang = Math.atan2(other.y-this.y, other.x-this.x); other.x += Math.cos(ang) * 5; other.y += Math.sin(ang) * 5; }}, 16);
                } else if(this.type === 'ez') {
                    sounds.skill(400);
                    for(let i=0; i<3; i++) setTimeout(() => { if(!gameActive) return; let sx, sy, sa, side = Math.floor(Math.random() * 4); if(side === 0) { sx = -200; sy = other.y; sa = 0; } else if(side === 1) { sx = canvas.width + 200; sy = other.y; sa = Math.PI; } else if(side === 2) { sx = other.x; sy = -200; sa = Math.PI/2; } else { sx = other.x; sy = canvas.height + 200; sa = -Math.PI/2; } projectiles.push(new Projectile(sx, sy, sa, '#ff0000', this, false, 'car')); }, i * 600);
                } else if(this.type === 'bb') {
                    sounds.skill(300); screenShake = 25; 
                    if(Math.hypot(other.x-this.x, other.y-this.y) < 380) { other.takeDamage(22); const ang = Math.atan2(other.y-this.y, other.x-this.x); other.x += Math.cos(ang) * 120; other.y += Math.sin(ang) * 120; projectiles.push(new Projectile(this.x, this.y, this.angle, this.color, this, false, 'wave')); }
                } else if(this.type === 'pig') {
                    sounds.skill(100); screenShake = 20; this.isSkillActive = true; this.skillCD = 400; setTimeout(() => { this.isSkillActive = false; }, 600);
                } else if(this.type === 'blade') { this.isDashing = true; this.dashTime = 14; this.dashAngle = this.angle; } 
                else if(this.type === 'shadow') { this.invul = 40; setTimeout(() => { if(!gameActive) return; this.x = other.x + Math.cos(this.angle+Math.PI)*120; this.y = other.y + Math.sin(this.angle+Math.PI)*120; other.takeDamage(20); }, 200); } 
                else if(this.type === 'volt') { this.isDashing = true; this.dashTime = 25; this.dashAngle = this.angle; const cV = setInterval(() => { if(!this.isDashing || !gameActive) clearInterval(cV); if(Math.hypot(this.x-other.x, this.y-other.y) < 80) other.takeDamage(1); }, 50); } 
                else if(this.type === 'sting') { for(let i=0; i<12; i++) projectiles.push(new Projectile(this.x, this.y, (Math.PI*2/12)*i, this.color, this)); } 
                else if(this.type === 'hacker') { this.invul = 60; for(let i=0; i<6; i++) setTimeout(() => { if(!gameActive) return; projectiles.push(new Projectile(this.x, this.y, Math.random()*Math.PI*2, this.color, this, true)); }, i*100); } 
                else if(this.type === 'reaper') { this.isDashing = true; this.dashTime = 12; this.dashAngle = this.angle; setTimeout(() => { if(!gameActive) return; if(Math.hypot(other.x-this.x, other.y-this.y) < 350) { other.takeDamage(25); other.slowEffect = 60; } }, 150); }
            }

            dash() { if(this.dashCD <= 0 && this.isStunned <= 0) { sounds.dash(); this.isDashing = true; this.dashTime = 10; this.dashAngle = this.angle; this.dashCD = 80; } }
            takeDamage(a) { if(this.invul > 0) return; sounds.hit(); let fD = a; const other = this.id === 1 ? p2 : p1; if(this.type === 'shinryu') fD *= 0.85; if(this.type === 'hong' && other.baseDmg > this.baseDmg) fD = a * 0.6; if(this.type === 'pig') fD *= 0.75; if(this.type === 'nasangsa') fD *= 1.5; this.hp -= fD; this.lastDamageTaken = fD; screenShake = Math.min(20, fD * 1.5); if(this.hp <= 0 && this.hasRebirth) this.triggerRebirth(); }
            triggerRebirth() { this.hasRebirth = false; this.hp = 50; this.invul = 90; screenShake = 40; sounds.skill(800); const passiveUI = document.getElementById(`p${this.id}-passive-ui`); if(passiveUI) { passiveUI.innerText = '패시브: 부활 [사용됨]'; passiveUI.style.color = '#ff3131'; } const other = this.id === 1 ? p2 : p1; if(Math.hypot(other.x-this.x, other.y-this.y) < 400) { const ang = Math.atan2(other.y-this.y, other.x-this.x); other.x += Math.cos(ang) * 200; other.y += Math.sin(ang) * 200; other.takeDamage(15); } this.isSkillActive = true; this.skillProg = 0; }

            draw() {
                if(this.magicFieldState) {
                    const mf = this.magicFieldState;
                    const scale = mf.timer > 150 ? (250 - mf.timer)/100 : (mf.timer < 30 ? mf.timer/30 : 1);
                    const safeScale = Math.max(0, scale);
                    ctx.save(); ctx.translate(mf.x, mf.y); ctx.rotate(Date.now() * 0.003); ctx.globalAlpha = safeScale * 0.5;
                    ctx.shadowBlur = 40; ctx.shadowColor = this.color; ctx.strokeStyle = this.color; ctx.lineWidth = 5; ctx.beginPath();
                    if(this.type === 'neonslime') { for(let i=0; i<8; i++) { const a = (i/8) * Math.PI * 2; const r = 250 * safeScale + (Math.sin(Date.now()*0.005 + i)*15); ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r); } }
                    else if(this.type === 'aurora') { for(let i=0; i<12; i++) { const a = (i/12) * Math.PI * 2; const r = 250 * safeScale + (Math.sin(Date.now()*0.005 + i)*20); ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r); } } 
                    else if(this.type === 'glitch') { for(let i=0; i<30; i++) { const px = (Math.random()-0.5) * 500 * safeScale; const py = (Math.random()-0.5) * 500 * safeScale; const sz = Math.random() * 20 * safeScale; ctx.fillStyle = this.color; ctx.fillRect(px, py, sz, sz); } } 
                    else if(this.type === 'crystalsummoner') { for(let i=0; i<8; i++) { const r = 250 * safeScale; const a = (i/8) * Math.PI * 2; ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r); } } 
                    else if(this.type === 'cybernecromancer') { for(let i=0; i<3; i++) { const r = 250 * safeScale; const a = (i/3) * Math.PI * 2; ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r); } } 
                    else { for(let i=0; i<6; i++) { const r = 250 * safeScale; const a = (i/6) * Math.PI * 2; ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r); } }
                    ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.arc(0,0, Math.max(0, 250*safeScale), 0, Math.PI*2); ctx.stroke(); ctx.restore();
                }
                if(this.meteorState) {
                    const ms = this.meteorState; ctx.save(); ctx.translate(ms.currentX, ms.currentY); ctx.rotate(Math.atan2(ms.vy, ms.vx));
                    const grad = ctx.createLinearGradient(0, 0, -600, 0); grad.addColorStop(0, this.color); grad.addColorStop(1, 'transparent');
                    ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(0, -150); ctx.lineTo(-700, 0); ctx.lineTo(0, 150); ctx.fill();
                    ctx.shadowBlur = 100; ctx.shadowColor = this.color; ctx.fillStyle = '#fff'; ctx.font = "bold 200px Montserrat"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("✦", 0, 0); ctx.restore();
                    if(ms.timer < 20) { ctx.save(); ctx.translate(ms.targetX, ms.targetY); ctx.globalAlpha = Math.max(0, ms.timer / 20); ctx.strokeStyle = this.color; ctx.lineWidth = 10; ctx.beginPath(); ctx.arc(0, 0, Math.max(0, (20 - ms.timer) * 30), 0, Math.PI*2); ctx.stroke(); ctx.restore(); }
                }
                if(this.blackHoleState) {
                    const bh = this.blackHoleState; 
                    const isNSS = this.type === 'nasangsa';
                    const maxT = isNSS ? 360 : 120;
                    const scale = bh.timer > (maxT-20) ? (maxT - bh.timer)/20 : (bh.timer < 20 ? bh.timer/20 : 1);
                    const safeScale = Math.max(0, scale); 
                    
                    ctx.save(); 
                    ctx.translate(bh.x, bh.y); 
                    ctx.rotate(Date.now() * (isNSS ? 0.015 : 0.005)); 
                    ctx.globalAlpha = safeScale * 0.45; 
                    ctx.shadowBlur = 60; 
                    ctx.shadowColor = this.color; 
                    
                    const bhSize = (isNSS ? 1000 : 330) * safeScale; 
                    ctx.drawImage(blackHoleImg, -bhSize/2, -bhSize/2, bhSize, bhSize); 
                    
                    if(isNSS) {
                        // 추가 토네이도 입자 효과
                        for(let i=0; i<15; i++) {
                            const pA = (i/15) * Math.PI * 2 + (Date.now() * 0.01);
                            const pR = (400 + Math.sin(Date.now()*0.005 + i)*50) * safeScale;
                            ctx.fillStyle = this.color;
                            ctx.beginPath();
                            ctx.arc(Math.cos(pA)*pR, Math.sin(pA)*pR, 10, 0, Math.PI*2);
                            ctx.fill();
                        }
                    }
                    ctx.restore();
                }
                
                if(this.sharkBiteState) {
                    const sb = this.sharkBiteState;
                    const sScale = Math.max(0, (40 - sb.timer) / 10);
                    const sW = 600 * sScale;
                    const sH = (nasangsaSharkImg.height / nasangsaSharkImg.width) * sW;
                    ctx.save();
                    ctx.translate(sb.x, sb.y);
                    ctx.shadowBlur = 50;
                    ctx.shadowColor = this.color;
                    ctx.globalAlpha = Math.min(1, sb.timer / 10);
                    ctx.drawImage(nasangsaSharkImg, -sW/2, -sH/2, sW, sH);
                    ctx.restore();
                }

                if(this.dragonHeadState) {
                    const ds = this.dragonHeadState; const scale = ds.timer > 120 ? (150 - ds.timer)/30 : (ds.timer < 30 ? ds.timer/30 : 1);
                    const safeScale = Math.max(0, scale); const dW = canvas.width * 0.6 * safeScale; const dH = (dragonImg.height / dragonImg.width) * dW; ctx.save(); ctx.translate(canvas.width / 2, canvas.height / 2); ctx.shadowBlur = 50; ctx.shadowColor = this.color; ctx.globalAlpha = safeScale; const hS = (Math.random() - 0.5) * 20 * safeScale; ctx.drawImage(dragonImg, -dW/2 + hS, -dH/2 + hS, dW, dH); ctx.restore();
                }
                if(this.nukeState) {
                    const ns = this.nukeState;
                    if(ns.phase === 'track' || ns.phase === 'warn') { ctx.save(); ctx.translate(ns.x, ns.y); ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 4; ctx.setLineDash([10, 5]); ctx.beginPath(); ctx.arc(0, 0, 250, 0, Math.PI*2); ctx.stroke(); if(Math.floor(Date.now()/200)%2) { ctx.fillStyle = '#ff0000'; ctx.font = "bold 20px Montserrat"; ctx.textAlign = "center"; ctx.fillText("⚠️ NUCLEAR THREAT ⚠️", 0, -270); } ctx.restore(); } 
                    else if(ns.phase === 'cloud') { ctx.save(); ctx.translate(ns.x, ns.y); ctx.globalAlpha = Math.max(0, ns.timer / 60); ctx.fillStyle = '#ff3131'; ctx.shadowBlur = 100; ctx.shadowColor = '#ff3131'; for(let i=0; i<8; i++) { const a = (i/8) * Math.PI * 2; ctx.beginPath(); ctx.arc(Math.cos(a)*100, -200 + Math.sin(a)*40, 80, 0, Math.PI*2); ctx.fill(); } ctx.restore(); }
                }

                ctx.save(); ctx.translate(this.x, this.y); if(this.invul > 0 && Math.floor(Date.now()/50)%2) ctx.globalAlpha = 0.4;
                if(this.isAttacking) {
                    ctx.save(); ctx.rotate(this.angle); ctx.strokeStyle = this.color; ctx.lineWidth = 10; ctx.globalAlpha = 1-this.atkProg; ctx.beginPath();
                    if(['nasangsa','neonslime','reaper','ez','hong','bulwark','pig','dragon','ghost','blood','cybersamurai','glitch','aurora'].includes(this.type)) { ctx.lineWidth = 15; ctx.arc(0,0, this.range, -1.8, 1.8); ctx.stroke(); } 
                    else if(['blade','shadow','void','volt'].includes(this.type)) { if(this.type !== 'volt') { ctx.arc(0,0, this.range, -1.0, 1.0); ctx.stroke(); } } 
                    else if(this.type === 'titan') { ctx.arc(0,0, Math.max(0, this.range*this.atkProg), 0, Math.PI*2); ctx.stroke(); } ctx.restore();
                }
                ctx.rotate(this.angle); ctx.shadowBlur = 30; ctx.shadowColor = this.color; ctx.fillStyle = '#0a0a0a'; ctx.strokeStyle = this.color; ctx.lineWidth = 5; ctx.beginPath();
                if(this.type === 'nasangsa') { ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius, -this.radius); ctx.lineTo(-this.radius/2, 0); ctx.lineTo(-this.radius, this.radius); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(5, -10, 3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 0.3; ctx.arc(0, 0, this.radius + 10, 0, Math.PI*2); ctx.stroke(); }
                else if(this.type === 'neonslime') { for(let i=0; i<8; i++) { const a = (i/8) * Math.PI * 2; const r = this.radius * (1 + Math.sin(Date.now()*0.005 + i)*0.1); ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r); } ctx.closePath(); ctx.fill(); ctx.stroke(); }
                else if(this.type === 'aurora') { for(let i=0; i<5; i++) { const a = (i/5) * Math.PI * 2; ctx.lineTo(Math.cos(a)*this.radius*1.2, Math.sin(a)*this.radius*1.2); const na = a + (Math.PI/5); ctx.lineTo(Math.cos(na)*this.radius*0.6, Math.sin(na)*this.radius*0.6); } ctx.closePath(); ctx.fill(); ctx.stroke(); } 
                else if(this.type === 'glitch') { const os = (Math.sin(this.glitchFrame*0.5)*5); ctx.fillRect(-this.radius+os, -this.radius, this.radius*2, this.radius*2); ctx.strokeRect(-this.radius+os, -this.radius, this.radius*2, this.radius*2); ctx.fillStyle = this.color; ctx.fillRect(-10+os, -10, 20, 20); } 
                else if(['witch', 'hanzo', 'cybernecromancer', 'crystalsummoner'].includes(this.type)) { ctx.moveTo(0, -this.radius); ctx.lineTo(this.radius, 0); ctx.lineTo(0, this.radius); ctx.lineTo(-this.radius, 0); ctx.closePath(); ctx.fill(); ctx.stroke(); }
                else if(this.type === 'ez') { ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius, -this.radius); ctx.lineTo(-this.radius, this.radius); ctx.closePath(); ctx.fill(); ctx.stroke(); }
                else if(this.type === 'void') { ctx.moveTo(-this.radius, -this.radius/2); ctx.lineTo(this.radius, 0); ctx.lineTo(-this.radius, this.radius/2); ctx.closePath(); ctx.fill(); ctx.stroke(); }
                else if(['shinryu', 'dragon', 'ghost', 'blood', 'cybersamurai'].includes(this.type)) { ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius, -this.radius); ctx.lineTo(-this.radius/2, 0); ctx.lineTo(-this.radius, this.radius); ctx.closePath(); ctx.fill(); ctx.stroke(); if(['dragon', 'ghost', 'blood', 'cybersamurai'].includes(this.type)) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(-10, 0, 5, 0, Math.PI*2); ctx.fill(); } }
                else if(['titan', 'hong', 'pig'].includes(this.type)) { const r = (this.type === 'pig' ? this.radius * 1.2 : this.radius); ctx.rect(-r,-r,r*2,r*2); ctx.fill(); ctx.stroke(); }
                else if(this.type === 'bulwark') { ctx.moveTo(-this.radius, -this.radius); ctx.lineTo(this.radius, -this.radius); ctx.lineTo(this.radius+10, 0); ctx.lineTo(this.radius, this.radius); ctx.lineTo(-this.radius, this.radius); ctx.closePath(); ctx.fill(); ctx.stroke(); }
                else if(this.type === 'phoenix') { ctx.moveTo(-this.radius, -10); ctx.lineTo(-this.radius-20, -30); ctx.lineTo(this.radius, 0); ctx.lineTo(-this.radius-20, 30); ctx.lineTo(-this.radius, 10); ctx.closePath(); ctx.fill(); ctx.stroke(); }
                else { ctx.arc(0,0, Math.max(0, this.radius), 0, Math.PI*2); ctx.fill(); ctx.stroke(); }
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.moveTo(this.radius-5, -12); ctx.lineTo(this.radius+15, 0); ctx.lineTo(this.radius-5, 12); ctx.fill(); ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, angle, color, owner, isGlitch = false, type = 'orb') {
                this.x = x; this.y = y; this.angle = angle; this.color = color; this.owner = owner; this.isGlitch = isGlitch; this.type = type;
                this.speed = (type === 'magic' && owner.type === 'nasangsa') ? 28 : (type === 'star') ? 16 : (type === 'cube' ? 15 : (type === 'magic' ? 12 : (type === 'paper' ? 18 : (type === 'car' ? 22 : (type === 'hog' ? 12 : (type === 'wave' ? 14 : (type === 'fire' ? 12 : (type === 'note' ? 15 : (type === 'gold' ? 20 : (type === 'shuriken' ? 24 : (type === 'dragon_breath' ? 9 : (type === 'blood_surge' ? 10 : (type === 'lightning' ? 0 : 14))))))))))))); 
                this.active = true; this.life = (type === 'star') ? 80 : (type === 'cube' ? 60 : (type === 'magic' ? 120 : (type === 'paper' ? 100 : (type === 'car' ? 250 : (type === 'hog' ? 150 : (type === 'fire' ? 40 : (type === 'gold' ? 60 : (type === 'shuriken' ? 50 : (type === 'dragon_breath' ? 80 : (type === 'blood_surge' ? 120 : (type === 'lightning' ? 15 : 100)))))))))));
                if(this.type === 'lightning') { this.points = this.generateLightningPoints(); }
            }
            generateLightningPoints() {
                const points = []; const segments = 6; const totalDist = this.owner.range;
                for(let i=0; i<=segments; i++) {
                    const d = (i/segments) * totalDist;
                    const offset = (i === 0 || i === segments) ? 0 : (Math.random()-0.5) * 60;
                    points.push({ d, offset });
                }
                return points;
            }
            update() {
                if(this.type === 'lightning') { if(--this.life <= 0) this.active = false; return; }
                const target = this.owner.id === 1 ? p2 : p1;
                if(this.type === 'magic' || this.type === 'star') { const aT = Math.atan2(target.y - this.y, target.x - this.x); this.angle += (aT - this.angle) * 0.05; }
                this.x += Math.cos(this.angle)*this.speed; this.y += Math.sin(this.angle)*this.speed; if(--this.life <= 0) this.active = false;
                const d = Math.hypot(this.x-target.x, this.y-target.y);
                const hR = ['star', 'car','paper','wave','fire','hog','note','gold','shuriken','dragon_breath','blood_surge'].includes(this.type) ? 60 : target.radius + 10;
                if(d < hR) {
                    const dmg = (this.type === 'star') ? 12 : (this.type === 'cube' ? 11 : (this.type === 'magic' ? 8 : (this.type === 'paper' ? 10 : (this.type === 'car' ? 25 : (this.type === 'hog' ? 5 : (this.type === 'wave' ? 10 : (this.type === 'fire' ? 4 : (this.type === 'note' ? 12 : (this.type === 'gold' ? 8 : (this.type === 'shuriken' ? 12 : (this.type === 'dragon_breath' ? 15 : (this.type === 'blood_surge' ? 25 : this.owner.baseDmg * 0.6))))))))))));
                    target.takeDamage(dmg); if(this.type === 'cube' || this.type === 'star') target.isStunned = 20; if(['fire', 'dragon_breath', 'blood_surge'].includes(this.type)) target.slowEffect = (this.type === 'blood_surge' ? 60 : 10);
                    if(this.owner.type === 'neonslime' && !this.slimeSpawned) { this.slimeSpawned = true; this.owner.magicFieldState = { x: target.x, y: target.y, timer: 120 }; }
                    if(!['star','car','wave','fire','hog','dragon_breath','blood_surge'].includes(this.type)) this.active = false;
                }
            }
            draw() {
                ctx.save(); ctx.shadowBlur = 20; ctx.shadowColor = this.color; ctx.fillStyle = this.color;
                if(this.type === 'lightning') {
                    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.strokeStyle = '#f0ff00'; ctx.lineWidth = 4; ctx.shadowBlur = 15; ctx.shadowColor = '#f0ff00'; ctx.beginPath(); ctx.moveTo(0, 0);
                    this.points.forEach(p => { ctx.lineTo(p.d, p.offset); }); ctx.stroke();
                    ctx.lineWidth = 1.5; ctx.strokeStyle = '#fff'; ctx.beginPath(); ctx.moveTo(0, 0); this.points.forEach(p => { ctx.lineTo(p.d, p.offset + (Math.random()-0.5)*5); }); ctx.stroke(); ctx.restore();
                }
                else if(this.type === 'star') { ctx.translate(this.x, this.y); ctx.rotate(Date.now()*0.01); ctx.font = "bold 24px Montserrat"; ctx.fillText("✦", -10, 10); }
                else if(this.type === 'cube') { ctx.translate(this.x, this.y); ctx.rotate(Date.now()*0.01); ctx.fillRect(-10, -10, 20, 20); }
                else if(this.type === 'magic') { ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, -8); ctx.lineTo(-10, 8); ctx.closePath(); ctx.fill(); }
                else if(this.type === 'shuriken') { ctx.translate(this.x, this.y); ctx.rotate(Date.now()*0.02); ctx.strokeStyle = this.color; ctx.lineWidth = 4; for(let i=0; i<4; i++) { ctx.beginPath(); ctx.rotate(Math.PI/2); ctx.moveTo(0, 0); ctx.lineTo(20, 5); ctx.lineTo(15, 0); ctx.lineTo(20, -5); ctx.closePath(); ctx.fill(); ctx.stroke(); } } 
                else if(this.type === 'paper') { ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#ffffff'; ctx.fillRect(-15, -20, 30, 40); } 
                else if(this.type === 'car') { ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#ff3333'; ctx.fillRect(-60, -30, 120, 60); } 
                else if(this.type === 'gold') { ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#ffcc00'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill(); } 
                else if(this.type === 'hog') { ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#6b4226'; ctx.beginPath(); ctx.ellipse(0, 0, 25, 15, 0, 0, Math.PI*2); ctx.fill(); } 
                else if(this.type === 'note') { ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.fillStyle = '#00ff00'; ctx.font = "bold 30px Arial"; ctx.fillText("🎵", -15, 10); } 
                else if(['wave', 'fire', 'dragon_breath', 'blood_surge'].includes(this.type)) { ctx.globalAlpha = Math.max(0, this.life / (this.type === 'dragon_breath' ? 80 : (this.type === 'blood_surge' ? 120 : 40))); ctx.strokeStyle = this.color; ctx.lineWidth = (this.type === 'dragon_breath' || this.type === 'blood_surge') ? 25 : 10; ctx.beginPath(); ctx.arc(this.x, this.y, (this.type === 'dragon_breath' || this.type === 'blood_surge') ? 50 : 40, this.angle - 0.5, this.angle + 0.5); ctx.stroke(); } 
                else { ctx.beginPath(); ctx.arc(this.x, this.y, 7, 0, Math.PI*2); ctx.fill(); } ctx.restore();
            }
        }

        const p1 = new Player(1), p2 = new Player(2);
        let projectiles = [];

        function loop() {
            ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle = '#050505'; ctx.fillRect(0,0,canvas.width,canvas.height);
            if(screenShake > 0) { ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake); screenShake *= 0.9; }
            if(gameActive) {
                p1.velX = 0; p1.velY = 0;
                if(p1.isStunned <= 0) {
                    if(keys['KeyW']) p1.velY = -p1.speed; if(keys['KeyS']) p1.velY = p1.speed; if(keys['KeyA']) p1.velX = -p1.speed; if(keys['KeyD']) p1.velX = p1.speed;
                    if(keys['KeyF']) p1.attack(); if(keys['KeyQ']) p1.dash(); if(keys['KeyE']) p1.useSkill();
                }
                if(gameMode === 'pvp' && p2.isStunned <= 0) {
                    p2.velX = 0; p2.velY = 0;
                    if(keys['ArrowUp']) p2.velY = -p2.speed; if(keys['ArrowDown']) p2.velY = p2.speed; if(keys['ArrowLeft']) p2.velX = -p2.speed; if(keys['ArrowRight']) p2.velX = p2.speed;
                    if(keys['KeyJ']) p2.attack(); if(keys['KeyK']) p2.dash(); if(keys['KeyL']) p2.useSkill();
                }
                timeLeft -= 0.016;
                if(timeLeft <= 0 || p1.hp <= 0 || p2.hp <= 0) { gameActive = false; document.getElementById('game-over').style.display = 'flex'; const winT = document.getElementById('winner-text'); const winner = p1.hp > p2.hp ? p1 : p2; if(winT) { winT.innerText = p1.hp > p2.hp ? "P1 VICTORY" : "P2 VICTORY"; winT.style.color = winner.color; winT.style.textShadow = `0 0 40px ${winner.color}`; } }
                document.getElementById('p1-dash-fill').style.height = (p1.dashCD/80)*100 + '%';
                document.getElementById('p1-skill-fill').style.height = (p1.skillCD/800)*100 + '%';
                document.getElementById('p2-dash-fill').style.height = (p2.dashCD/80)*100 + '%';
                document.getElementById('p2-skill-fill').style.height = (p2.skillCD/800)*100 + '%';
            }
            p1.update(); p2.update(); projectiles = projectiles.filter(p => p.active); projectiles.forEach(p => { p.update(); p.draw(); }); p1.draw(); p2.draw();
            document.getElementById('p1-hp').style.width = Math.max(0, p1.hp) + '%'; document.getElementById('p1-hp').style.backgroundColor = p1.color;
            document.getElementById('p2-hp').style.width = Math.max(0, p2.hp) + '%'; document.getElementById('p2-hp').style.backgroundColor = p2.color;
            document.getElementById('timer').innerText = Math.ceil(Math.max(0, timeLeft));
            requestAnimationFrame(loop);
        }
        updateCharUI(1); updateCharUI(2); window.onload = loop;
    </script>
</body>
</html>
